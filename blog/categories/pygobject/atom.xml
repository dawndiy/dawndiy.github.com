<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: PyGObject | 一个人的世界]]></title>
  <link href="http://dawndiy.github.com/blog/categories/pygobject/atom.xml" rel="self"/>
  <link href="http://dawndiy.github.com/"/>
  <updated>2013-03-07T21:40:55+08:00</updated>
  <id>http://dawndiy.github.com/</id>
  <author>
    <name><![CDATA[DawnDIY]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PyGObject 学习笔记(10)-GMenu &#038; GSimpleAction]]></title>
    <link href="http://dawndiy.github.com/archives/442"/>
    <updated>2013-02-06T00:00:00+08:00</updated>
    <id>http://dawndiy.github.com/archives/pygobject-study-notes-10-gmenu-gsimpleaction</id>
    <content type="html"><![CDATA[<h1></h1>

<p>有段时间没更新了，一直想着想重新改一下Bolg，所以没怎么写了。好~二话不说，现在继续。今天来讲一个新的控件，一看标题，对！又是菜单，但这次菜单和之前的<a href="http://www.dawndiy.com/archives/290" title="PyGtk学习笔记(6)–菜单">《PyGtk学习笔记(6)–菜单》</a>的菜单是不同，自从转向学习PyGObject了，会有很多GTK 3的特性，所以，这次的 GMenu 和以往的菜单不同。所以老规矩，看图吧。</p>

<p><img src="http://i.imgur.com/sNe0XA5.jpg" title="GMenu" alt="" /></p>

<p>上面的图就是 GMenu 在原生 Gnome3 桌面里面显示的效果。好了，开始介绍。</p>

<h2>一. 介绍</h2>

<p>Ubuntu 的 Unity 桌面使用了全局菜单，为应用程序增加了很多可视空间。当然，在 Gnome3 里面同样可以省去传统的 MenuBar ，根据 Gnome3 的新特性，增加了 GMenu 。就像上面的图一样，将菜单功能集成在 Gnome 的任务栏中，同样为用户挤出了更多的空间，而且现在很多 Gnome3 的应用也开始使用这一特性了，如：Empathy。当然，刚开始很多童鞋找不到菜单在最顶上，呵呵，不过发现了以后还是会比较惊喜，这样会省出一个 Bar 的空间。</p>

<h3>1.类结构</h3>

<p>```</p>

<pre><code>GObject
    ----GMenuModel
          ----GMenu
</code></pre>

<p>```
要注意的是，GMenu 是在 GIO 中，而不是在 GTK 中，所以应该导入 Gio 模块</p>

<!-- more -->


<p>``` python</p>

<pre><code>from gi.repository import Gio
</code></pre>

<p>```</p>

<h3> 2.常用方法</h3>

<p>``` python</p>

<pre><code>insert(position, label, detailed_action)
append(label, detailed_action)   # 加到最后
prepend(label, detailed_action)  # 加到最前
</code></pre>

<p><code>
在菜单中插入一个选项  
*position: 位置*  
*label: 显示标签*  
*detailed_action: 动作名，以 app. 为前缀*
</code> python</p>

<pre><code>insert_section(position, label, section)
append_section(label, section)
prepend_section(label, section)
</code></pre>

<p><code>
在菜单中插入一个区域，上下会有分割线隔开  
*position: 位置*  
*label: 区域名*  
*section: 可以是一个 GMenu*
</code> python</p>

<pre><code>insert_submenu(position, label, section)
append_submenu(label, section)
prepend_submenu(label, section)
</code></pre>

<p><code>
在菜单中插入一个子菜单  
*position: 位置*  
*label: 区域名*  
*section: 可以是一个 GMenu*
</code> python</p>

<pre><code>remove(postion)    # 删除选项
set_label(label)   # 设置显示标签
</code></pre>

<p>```</p>

<h3> 2.代码分析</h3>

<p>以下是是想最上面图中的菜单的效果：
``` python</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

# GMenu &amp; SimpleActions
# PyGObject Study Notes By DawnDIY
# http://dawndiy.com

from gi.repository import Gtk
from gi.repository import Gio
import sys

class MyWindow(Gtk.ApplicationWindow):
    def __init__(self, app):
        Gtk.Window.__init__(self, title="GMenu Example", application=app)

class MyApplication(Gtk.Application):
    def __init__(self):
        Gtk.Application.__init__(self)

    def do_activate(self):
        win = MyWindow(self)
        win.show_all()

    def do_startup (self):
        # 启动应用
        Gtk.Application.do_startup(self)

        # 建立顶层菜单
        menu = Gio.Menu()
        # 新建三个菜单选项
        item_new = Gio.MenuItem.new("New", "app.new")
        item_about = Gio.MenuItem.new("About", "app.about")
        item_quit = Gio.MenuItem.new("Quit", "app.quit")

        # 建立菜单，作为子菜单
        submenu = Gio.Menu()
        # 直接添加2个选项
        submenu.append("sub_New", "app.new")
        submenu.append("sub_About", "app.about")

        # 建立菜单，作为父菜单
        menu2 = Gio.Menu()
        # 将子菜单添加进来
        menu2.append_submenu("Sub", submenu)
        menu2.append("exit", "app.quit")

        # 把选项、父菜单都加入到顶层菜单中
        menu.append_item(item_new)
        menu.append_item(item_about)
        menu.append_section("", menu2)  # 父菜单添加为不同菜单区域
        menu.append_item(item_quit)

        # 将顶层菜单作为应用程序的菜单
        self.set_app_menu(menu)

        # 为菜单 new 选项添加动作
        new_action = Gio.SimpleAction.new("new", None)
        # 连接到回调函数 new_cb
        new_action.connect("activate", self.new_cb)
        # 将动作添加到应用中 
        self.add_action(new_action)

        # about 选项
        about_action = Gio.SimpleAction.new("about", None)
        about_action.connect("activate", self.about_cb)
        self.add_action(about_action)

        # quit 选项 
        quit_action = Gio.SimpleAction.new("quit", None)
        quit_action.connect("activate", self.quit_cb)
        self.add_action(quit_action)

    # new 的回调函数 
    def new_cb(self, action, parameter):
        print("This does nothing. It is only a demonstration.")

    # about 的回调函数 
    def about_cb(self, action, parameter):
        print("No AboutDialog for you. This is only a demonstration.")

    # about 的回调函数 
    def quit_cb(self, action, parameter):
        print("You have quit.")
        self.quit()

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
</code></pre>

<p>```
代码中我已经注释的很详细了，相信认真看都能看懂的！下面我就补充一下前面提到的 GSimpleAction 。</p>

<p>GSimpleAction 继承自 GObject， 用于建立一个独立的动作，使用它可以连接你的回调函数。</p>

<p>常用函数有：
``` python</p>

<pre><code>action = Gio.SimpleAction.new("name", parameter_type)
</code></pre>

<p><code>
*新建一个动作*  
*name: 动作名*  
*parameter_type: 参数类型，可以为 None*
</code> python</p>

<pre><code>set_enabled(True)
</code></pre>

<p>```
<em>设置是否启用</em></p>

<h3>3.总结</h3>

<p>好吧，又写了一篇。希望感兴趣的朋友们能一起来交流！我刚看到 GMenu 的时候是用 Empathy 的时候发现它的菜单变化了，不过第一次用确实没找到菜单，呵呵，最后才知道这样的设计其实挺好的，节省了可视空间，尤其是在你的应用有很复杂的UI的时候，最后还是谈到用户体验了。</p>

<p>PS：这次我学 GMenu 的时候其实我也找了很多资料，不过 PyGObject 的资料不多，最后还是拿着 C 的 GTK 开发手册（就是那个devhelp）一个个函数看的。所以，还是要多看看 API 文档。</p>

<p>待续。。。</p>

<p> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PyGObject 学习笔记(9)-标签]]></title>
    <link href="http://dawndiy.github.com/archives/399"/>
    <updated>2012-11-15T00:00:00+08:00</updated>
    <id>http://dawndiy.github.com/archives/pygobject-study-notes-9-label</id>
    <content type="html"><![CDATA[<h1></h1>

<p>Label (标签)可以说是任何应用中最常见的控件了，使用标签是在窗口中显示不可编辑的文字的最常用方法。简单讲就是用来显示信息的。我们从最简单的 Hello World 例子看一下，如图：</p>

<p><img src="http://i.imgur.com/BmAKT.png" title="Label_hello_world" alt="" /></p>

<p>就像上面的图一样，就是显示一个简单的信息，完整代码如下：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Label Example
# PyGObject Study Notes By DawnDIY
# http://dawndiy.com

from gi.repository import Gtk

class LabelWindow(Gtk.Window):

    def __init__(self):
        Gtk.Window.__init__(self, title="Label Example")

        label = Gtk.Label("Hello World!")

        self.add(label)

win = LabelWindow()
win.connect("delete-event", Gtk.main_quit)
win.show_all()
Gtk.main()
</code></pre>

<p>是不是很简单，<strong>但是，不是仅仅如此哦。</strong>其实 Label 也有挺多显示方法的，如果选择合适的显示，会给你的窗口添加不少亮点，下面我们就详细看一下。</p>

<p>先从 Label 对象看起：</p>

<pre><code>class Gtk.Label([text ])
</code></pre>

<p>在新建一个 Label 时，可以直接附上 text 的内容即可，如果没有值即空。</p>

<p>常用方法：</p>

<pre><code>static new_with_mnemonic(text)
</code></pre>

<p>这是一个静态方法，返回的也是一个Label。但是有所不同的是，这个方法可以设置类似快捷键的事件，通过下划线(_)来指定快捷键字母，当然这个方法要配合 set_mnemonic_widget(widget) 来使用，通过键盘上按下 Alt [指定字母] 来激活 set_mnemonic_widget(widget) 绑定的控件的事件。详情看后面例子。</p>

<pre><code>set_mnemonic_widget(widget)
</code></pre>

<p>设置前面指定快捷键激活的控件事件。如果为空或者没有使用该方法，则默认为 Label 本身。</p>

<pre><code>set_justify(justification)
</code></pre>

<p>使用这个方法设置文字的对齐方式。</p>

<p><strong><code>justification
</code></strong></p>

<p>可以是：Gtk.Justification.LEFT, Gtk.Justification.RIGHT, Gtk.Justification.CENTER,<br/>
Gtk.Justification.FILL. 分别是左对齐，右对齐，居中和填充。不过这个方法对尽有一行文字的Label是无效的。</p>

<pre><code>set_line_wrap(wrap)
</code></pre>

<p>这个是控制内容换行的。当 <em>wrap</em> 的值为 True ，如果一行内容超过了 Label 控件的大小，那么将内容换行显示。当 <em>wrap</em> 的值为 False ，如果一行内容超过了 Label 控件的大小，内容将被剪切掉。</p>

<pre><code>set_markup(markup)
</code></pre>

<p>这个是好东西，可以让你的 Label 显示更加丰富，通过该方法让 Label 的内容支持标记输出，其中的标记必须符合 Pango 的文本标记语言，如, &amp; 字符都要用 &lt; > &amp;amp 来替换。下面的完整例子中会用到。</p>

<pre><code>set_selectable(selectable)
</code></pre>

<p>这个方法设置文本内容是否可选择，<em>selectable </em>默认是 False，即不可选，为 Ture 时则可以供用户选择用户复制粘贴。</p>

<pre><code>set_text(text)
</code></pre>

<p>这个就不用多说了，看它就知道是干嘛的啦，使用它可以随时更改 Label 的内容。</p>

<p>好的，我们现在汇总一下看一个比较长的例子，上图先，呵呵：</p>

<p><img src="http://i.imgur.com/4o88f.png" title="label_example" alt="" /></p>

<p>这个例子包含了上面我讲到的常用方法，和一些 Label 的用法，看看完整的源代码和 Label 的内容你就懂啦~</p>

<p>完整代码：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Label Example
# PyGObject Study Notes By DawnDIY
# http://dawndiy.com

from gi.repository import Gtk

class LabelWindow(Gtk.Window):

    def __init__(self):
        Gtk.Window.__init__(self, title="Label Example")
        hbox = Gtk.Box(spacing=10)
        hbox.set_homogeneous(False)
        vbox_left = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        vbox_left.set_homogeneous(False)
        vbox_right = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        vbox_right.set_homogeneous(False)
        hbox.pack_start(vbox_left, True, True, 0)
        hbox.pack_start(vbox_right, True, True, 0)
        label = Gtk.Label("这是一个普通 label")
        vbox_left.pack_start(label, True, True, 0)
        label = Gtk.Label()
        label.set_text("这是一个左对齐的 label。n包含多行。")
        label.set_justify(Gtk.Justification.LEFT)
        vbox_left.pack_start(label, True, True, 0)
        label = Gtk.Label("这是一个右对齐的 label。n包含多行。")
        label.set_justify(Gtk.Justification.RIGHT)
        vbox_left.pack_start(label, True, True, 0)
        label = Gtk.Label("这是一个多行显示的 label 示例。它"
                            "不是占据所有能容纳下它的"
                            "宽度，而是自动的换行调整适应。n"
                            "并且它支持多段落正确的显示，"
                            "正确的补充额外的空间。")
        label.set_line_wrap(True)
        vbox_right.pack_start(label, True, True, 0)
        label = Gtk.Label("这是一个多行显示的 label 示例，填充式 label 。"
                            "它会占据所有能容纳下它的宽度。 "
                            "好，来几个句子证明我的说法。"
                            "这又是一个句子。又来一个句子，巴拉巴拉巴拉。n"
                            "这是一个新段落~n"
                            "好吧，这又是一个扯淡的段落，扯点"
                            "什么呢？元芳，你怎么看啊？呵呵~")
        label.set_line_wrap(True)
        label.set_justify(Gtk.Justification.FILL)
        vbox_right.pack_start(label, True, True, 0)
        label = Gtk.Label()
        label.set_markup("文本内容可以 小, 大, "
                            "粗体, 斜体 甚至可以是超链接 "
                            " 网络.")
        label.set_line_wrap(True)
        vbox_left.pack_start(label, True, True, 0)
        label = Gtk.Label.new_with_mnemonic("按下 Alt   P 来选择右边的按钮 (_P)")
        vbox_left.pack_start(label, True, True, 0)
        label.set_selectable(True)
        button = Gtk.Button(label="点一下试一试")
        label.set_mnemonic_widget(button)
        vbox_right.pack_start(button, True, True, 0)
        self.add(hbox)

window = LabelWindow()
window.connect("delete-event", Gtk.main_quit)
window.show_all()
Gtk.main()
</code></pre>

<p>好啦~ Label 挺简单的。。。 用好 mark 会表现的更出色的。 See you next time~</p>

<p>现在开始，之前的代码都传到 github 上去了。<br/>
文中的例子在这里：  </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PyGObject 学习笔记(8)-消息对话框]]></title>
    <link href="http://dawndiy.github.com/archives/378"/>
    <updated>2012-10-19T00:00:00+08:00</updated>
    <id>http://dawndiy.github.com/archives/pygobject-study-notes-8-message-dialog</id>
    <content type="html"><![CDATA[<h1></h1>

<p>写在前面，先扯点无聊的。这几天回家才有时间用电脑，刚好昨天升级了一下 Ubuntu 12.10 。然后当然也要更新一下学习笔记，学习在于坚持嘛~ 可能发现标题不同了，不错，我在前几天谈到我的学习心得和经历让我做出了选择，一定要向前，用GTK 3 所以选择PyGObject。可以看我写的<a href="http://www.dawndiy.com/archives/373" title="PyGTK or PyGObject">《PyGtk or PyGObject》</a>，也扯了一些有的没的。</p>

<p>好了，正题开始，今天在一点点的码自己的项目的时候要用到一个很重要的东西，那就是“消息对话框”，即 Message Dialog 。这个是什么了，如果你不知道那就快回火星吧！上图！</p>

<p><img src="http://i.imgur.com/u9Xjl.png" title="Info_message_dialog" alt="" /></p>

<p>对，就是上面这个图，你见过吧。消息对话框在程序中随处可见，他的作用就是提示或弹出一个信息让用户得知，所以消息对话框在交互方面和用户体验方面也是挺重要的。</p>

<p>在GTK 3中，构建消息对话框的类是<strong>MessageDialog</strong>。下面来看一下这个类：</p>

<pre><code>class Gtk.MessageDialog(parent=None, flags=0, type=Gtk.MESSAGE_INFO, buttons=Gtk.BUTTONS_NONE, message_format=None)
</code></pre>

<p>  <strong><code>parent</code></strong> :</p>

<p>父控件，一般是窗体</p>

<p><strong><code>flags</code></strong> :</p>

<p>对话框标识，可以是 Gtk.DialogFlags.MODAL，<code>Gtk.DIALOG_DESTROY_WITH_PARENT</code> 或 0</p>

<p><strong><code>type</code></strong> :</p>

<p>消息的类型，可以是 <code>Gtk.MESSAGE_INFO</code>, <code>Gtk.MESSAGE_WARNING</code>, <code>Gtk.MESSAGE_QUESTION</code> 或<code>Gtk.MESSAGE_ERROR</code>.</p>

<p><strong><code>buttons</code></strong> :</p>

<p>可以使用预定义的按钮： <code>Gtk.BUTTONS_NONE</code>, <code>Gtk.BUTTONS_OK</code>, <code>Gtk.BUTTONS_CLOSE</code>, <code>Gtk.BUTTONS_CANCEL</code>, <code>Gtk.BUTTONS_YES_NO</code>, <code>Gtk.BUTTONS_OK_CANCEL 等
</code></p>

<p><strong><code>message_format</code></strong> :</p>

<p>消息的内容</p>

<p><em>Returns</em> :</p>

<p> <code>G``tk.MessageDialog</code></p>

<p>上面就是构造消息对话框的 MessageDialog 类啦。</p>

<p>现在看一下我们最上面那个图的代码是怎么样的：</p>

<pre><code>dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.INFO,Gtk.ButtonsType.OK, "这是一个信息消息对话框")
dialog.format_secondary_text("这里是副文本用于说明信息。")
dialog.run()
dialog.destroy()
</code></pre>

<p>这是一个消息对话框的部分代码。是不是很简单，然而上面多了几个函数下面解释：</p>

<pre><code>dialog.format_secondary_text("这里是副文本用于说明信息。")
</code></pre>

<p>这个看图也知道啊，就是现实在下面的副文本，可以用来显示解释性文字。</p>

<pre><code>dialog.run()
dialog.destroy()
</code></pre>

<p>run执行后，对话框就会显示了，这时候对话框不会马上去执行后面的destroy来销毁，而是等待我们的一个按键响应再来销毁，所以这就是消息对话框有按钮的原因了。</p>

<p>上面的例子我们没有或得到按键响应，其实我们的按键响应就是由 <strong>dialog.run()</strong> 来返回的，所以中断在它这里嘛~那我们再看一个能获取按键的例子，惯例，上图先：</p>

<p><img src="http://i.imgur.com/0qnC7.png" title="question_message_dialog" alt="" /></p>

<p>看吧，这样的消息对话框就有两个按钮分别让你选择。看下局部代码：</p>

<pre><code>dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.QUESTION, Gtk.ButtonsType.YES_NO, "这是一个询问消息对话框")
dialog.format_secondary_text("这里是副文本用于说明信息。")
response = dialog.run()
if response == Gtk.ResponseType.YES:
    print("YES button is clicked")
elif response == Gtk.ResponseType.NO:
    print("NO button is clicked")
dialog.destroy()
</code></pre>

<p>看到代码中我们定义了一个名为 response 的变量来接受 dialog.run() 的返回，然后再做出判断分别处理就OK啦。。。</p>

<p>好了，差不多就这些吧~大家可以试一试，我把写好的一个完整的 Demo 贴出来：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*
# MessageDialog
# PyGtk Study Notes By DawnDIY
# http://www.dawndiy.com 

from gi.repository import Gtk

class MessageDialogWindow(Gtk.Window):

    def __init__(self):
        Gtk.Window.__init__(self, title="MessageDialog Example")

        box = Gtk.Box(spacing=6)
        self.add(box)

        button1 = Gtk.Button("信息")
        button1.connect("clicked", self.on_info_clicked)
        box.add(button1)

        button2 = Gtk.Button("错误")
        button2.connect("clicked", self.on_error_clicked)
        box.add(button2)

        button3 = Gtk.Button("警告")
        button3.connect("clicked", self.on_warn_clicked)
        box.add(button3)

        button4 = Gtk.Button("询问")
        button4.connect("clicked", self.on_question_clicked)
        box.add(button4)

    def on_info_clicked(self, widget):
        dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.INFO,
        Gtk.ButtonsType.OK, "这是一个信息消息对话框")
        dialog.format_secondary_text(
        "这里是副文本用于说明信息。")
        dialog.run()
        print "INFO dialog closed"

        dialog.destroy()

    def on_error_clicked(self, widget):
        dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.ERROR,
        Gtk.ButtonsType.CANCEL, "这是一个错误消息对话框")
        dialog.format_secondary_text("这里是副文本用于说明信息。")
        dialog.run()
        print "ERROR dialog closed"

        dialog.destroy()

    def on_warn_clicked(self, widget):
        dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.WARNING,
        Gtk.ButtonsType.OK_CANCEL, "这是一个警告消息对话框")
        dialog.format_secondary_text(
        "这里是副文本用于说明信息。")
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            print "OK button is clicked"
        elif response == Gtk.ResponseType.CANCEL:
            print "CANCEL button is clicked"

        dialog.destroy()

    def on_question_clicked(self, widget):
        dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.QUESTION,
        Gtk.ButtonsType.YES_NO, "这是一个询问消息对话框")
        dialog.format_secondary_text(
        "这里是副文本用于说明信息。")
        response = dialog.run()
        if response == Gtk.ResponseType.YES:
            print "YES button is clicked"
        elif response == Gtk.ResponseType.NO:
            print "NO button is clicked"

        dialog.destroy()

win = MessageDialogWindow()
win.connect("delete-event", Gtk.main_quit)
win.show_all()
Gtk.main()
</code></pre>

<p>效果自己去运行就知道了<del>OK~最近好忙啊，好不容易偷个懒上下网</del>下回继续…….</p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
  </entry>
  
</feed>
