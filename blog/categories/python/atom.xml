<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | 一个人的世界]]></title>
  <link href="http://dawndiy.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://dawndiy.github.com/"/>
  <updated>2013-03-07T21:40:55+08:00</updated>
  <id>http://dawndiy.github.com/</id>
  <author>
    <name><![CDATA[DawnDIY]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PyGObject 学习笔记(10)-GMenu &#038; GSimpleAction]]></title>
    <link href="http://dawndiy.github.com/archives/442"/>
    <updated>2013-02-06T00:00:00+08:00</updated>
    <id>http://dawndiy.github.com/archives/pygobject-study-notes-10-gmenu-gsimpleaction</id>
    <content type="html"><![CDATA[<h1></h1>

<p>有段时间没更新了，一直想着想重新改一下Bolg，所以没怎么写了。好~二话不说，现在继续。今天来讲一个新的控件，一看标题，对！又是菜单，但这次菜单和之前的<a href="http://www.dawndiy.com/archives/290" title="PyGtk学习笔记(6)–菜单">《PyGtk学习笔记(6)–菜单》</a>的菜单是不同，自从转向学习PyGObject了，会有很多GTK 3的特性，所以，这次的 GMenu 和以往的菜单不同。所以老规矩，看图吧。</p>

<p><img src="http://i.imgur.com/sNe0XA5.jpg" title="GMenu" alt="" /></p>

<p>上面的图就是 GMenu 在原生 Gnome3 桌面里面显示的效果。好了，开始介绍。</p>

<h2>一. 介绍</h2>

<p>Ubuntu 的 Unity 桌面使用了全局菜单，为应用程序增加了很多可视空间。当然，在 Gnome3 里面同样可以省去传统的 MenuBar ，根据 Gnome3 的新特性，增加了 GMenu 。就像上面的图一样，将菜单功能集成在 Gnome 的任务栏中，同样为用户挤出了更多的空间，而且现在很多 Gnome3 的应用也开始使用这一特性了，如：Empathy。当然，刚开始很多童鞋找不到菜单在最顶上，呵呵，不过发现了以后还是会比较惊喜，这样会省出一个 Bar 的空间。</p>

<h3>1.类结构</h3>

<p>```</p>

<pre><code>GObject
    ----GMenuModel
          ----GMenu
</code></pre>

<p>```
要注意的是，GMenu 是在 GIO 中，而不是在 GTK 中，所以应该导入 Gio 模块</p>

<!-- more -->


<p>``` python</p>

<pre><code>from gi.repository import Gio
</code></pre>

<p>```</p>

<h3> 2.常用方法</h3>

<p>``` python</p>

<pre><code>insert(position, label, detailed_action)
append(label, detailed_action)   # 加到最后
prepend(label, detailed_action)  # 加到最前
</code></pre>

<p><code>
在菜单中插入一个选项  
*position: 位置*  
*label: 显示标签*  
*detailed_action: 动作名，以 app. 为前缀*
</code> python</p>

<pre><code>insert_section(position, label, section)
append_section(label, section)
prepend_section(label, section)
</code></pre>

<p><code>
在菜单中插入一个区域，上下会有分割线隔开  
*position: 位置*  
*label: 区域名*  
*section: 可以是一个 GMenu*
</code> python</p>

<pre><code>insert_submenu(position, label, section)
append_submenu(label, section)
prepend_submenu(label, section)
</code></pre>

<p><code>
在菜单中插入一个子菜单  
*position: 位置*  
*label: 区域名*  
*section: 可以是一个 GMenu*
</code> python</p>

<pre><code>remove(postion)    # 删除选项
set_label(label)   # 设置显示标签
</code></pre>

<p>```</p>

<h3> 2.代码分析</h3>

<p>以下是是想最上面图中的菜单的效果：
``` python</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

# GMenu &amp; SimpleActions
# PyGObject Study Notes By DawnDIY
# http://dawndiy.com

from gi.repository import Gtk
from gi.repository import Gio
import sys

class MyWindow(Gtk.ApplicationWindow):
    def __init__(self, app):
        Gtk.Window.__init__(self, title="GMenu Example", application=app)

class MyApplication(Gtk.Application):
    def __init__(self):
        Gtk.Application.__init__(self)

    def do_activate(self):
        win = MyWindow(self)
        win.show_all()

    def do_startup (self):
        # 启动应用
        Gtk.Application.do_startup(self)

        # 建立顶层菜单
        menu = Gio.Menu()
        # 新建三个菜单选项
        item_new = Gio.MenuItem.new("New", "app.new")
        item_about = Gio.MenuItem.new("About", "app.about")
        item_quit = Gio.MenuItem.new("Quit", "app.quit")

        # 建立菜单，作为子菜单
        submenu = Gio.Menu()
        # 直接添加2个选项
        submenu.append("sub_New", "app.new")
        submenu.append("sub_About", "app.about")

        # 建立菜单，作为父菜单
        menu2 = Gio.Menu()
        # 将子菜单添加进来
        menu2.append_submenu("Sub", submenu)
        menu2.append("exit", "app.quit")

        # 把选项、父菜单都加入到顶层菜单中
        menu.append_item(item_new)
        menu.append_item(item_about)
        menu.append_section("", menu2)  # 父菜单添加为不同菜单区域
        menu.append_item(item_quit)

        # 将顶层菜单作为应用程序的菜单
        self.set_app_menu(menu)

        # 为菜单 new 选项添加动作
        new_action = Gio.SimpleAction.new("new", None)
        # 连接到回调函数 new_cb
        new_action.connect("activate", self.new_cb)
        # 将动作添加到应用中 
        self.add_action(new_action)

        # about 选项
        about_action = Gio.SimpleAction.new("about", None)
        about_action.connect("activate", self.about_cb)
        self.add_action(about_action)

        # quit 选项 
        quit_action = Gio.SimpleAction.new("quit", None)
        quit_action.connect("activate", self.quit_cb)
        self.add_action(quit_action)

    # new 的回调函数 
    def new_cb(self, action, parameter):
        print("This does nothing. It is only a demonstration.")

    # about 的回调函数 
    def about_cb(self, action, parameter):
        print("No AboutDialog for you. This is only a demonstration.")

    # about 的回调函数 
    def quit_cb(self, action, parameter):
        print("You have quit.")
        self.quit()

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
</code></pre>

<p>```
代码中我已经注释的很详细了，相信认真看都能看懂的！下面我就补充一下前面提到的 GSimpleAction 。</p>

<p>GSimpleAction 继承自 GObject， 用于建立一个独立的动作，使用它可以连接你的回调函数。</p>

<p>常用函数有：
``` python</p>

<pre><code>action = Gio.SimpleAction.new("name", parameter_type)
</code></pre>

<p><code>
*新建一个动作*  
*name: 动作名*  
*parameter_type: 参数类型，可以为 None*
</code> python</p>

<pre><code>set_enabled(True)
</code></pre>

<p>```
<em>设置是否启用</em></p>

<h3>3.总结</h3>

<p>好吧，又写了一篇。希望感兴趣的朋友们能一起来交流！我刚看到 GMenu 的时候是用 Empathy 的时候发现它的菜单变化了，不过第一次用确实没找到菜单，呵呵，最后才知道这样的设计其实挺好的，节省了可视空间，尤其是在你的应用有很复杂的UI的时候，最后还是谈到用户体验了。</p>

<p>PS：这次我学 GMenu 的时候其实我也找了很多资料，不过 PyGObject 的资料不多，最后还是拿着 C 的 GTK 开发手册（就是那个devhelp）一个个函数看的。所以，还是要多看看 API 文档。</p>

<p>待续。。。</p>

<p> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PyGObject 学习笔记(9)-标签]]></title>
    <link href="http://dawndiy.github.com/archives/399"/>
    <updated>2012-11-15T00:00:00+08:00</updated>
    <id>http://dawndiy.github.com/archives/pygobject-study-notes-9-label</id>
    <content type="html"><![CDATA[<h1></h1>

<p>Label (标签)可以说是任何应用中最常见的控件了，使用标签是在窗口中显示不可编辑的文字的最常用方法。简单讲就是用来显示信息的。我们从最简单的 Hello World 例子看一下，如图：</p>

<p><img src="http://i.imgur.com/BmAKT.png" title="Label_hello_world" alt="" /></p>

<p>就像上面的图一样，就是显示一个简单的信息，完整代码如下：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Label Example
# PyGObject Study Notes By DawnDIY
# http://dawndiy.com

from gi.repository import Gtk

class LabelWindow(Gtk.Window):

    def __init__(self):
        Gtk.Window.__init__(self, title="Label Example")

        label = Gtk.Label("Hello World!")

        self.add(label)

win = LabelWindow()
win.connect("delete-event", Gtk.main_quit)
win.show_all()
Gtk.main()
</code></pre>

<p>是不是很简单，<strong>但是，不是仅仅如此哦。</strong>其实 Label 也有挺多显示方法的，如果选择合适的显示，会给你的窗口添加不少亮点，下面我们就详细看一下。</p>

<p>先从 Label 对象看起：</p>

<pre><code>class Gtk.Label([text ])
</code></pre>

<p>在新建一个 Label 时，可以直接附上 text 的内容即可，如果没有值即空。</p>

<p>常用方法：</p>

<pre><code>static new_with_mnemonic(text)
</code></pre>

<p>这是一个静态方法，返回的也是一个Label。但是有所不同的是，这个方法可以设置类似快捷键的事件，通过下划线(_)来指定快捷键字母，当然这个方法要配合 set_mnemonic_widget(widget) 来使用，通过键盘上按下 Alt [指定字母] 来激活 set_mnemonic_widget(widget) 绑定的控件的事件。详情看后面例子。</p>

<pre><code>set_mnemonic_widget(widget)
</code></pre>

<p>设置前面指定快捷键激活的控件事件。如果为空或者没有使用该方法，则默认为 Label 本身。</p>

<pre><code>set_justify(justification)
</code></pre>

<p>使用这个方法设置文字的对齐方式。</p>

<p><strong><code>justification
</code></strong></p>

<p>可以是：Gtk.Justification.LEFT, Gtk.Justification.RIGHT, Gtk.Justification.CENTER,<br/>
Gtk.Justification.FILL. 分别是左对齐，右对齐，居中和填充。不过这个方法对尽有一行文字的Label是无效的。</p>

<pre><code>set_line_wrap(wrap)
</code></pre>

<p>这个是控制内容换行的。当 <em>wrap</em> 的值为 True ，如果一行内容超过了 Label 控件的大小，那么将内容换行显示。当 <em>wrap</em> 的值为 False ，如果一行内容超过了 Label 控件的大小，内容将被剪切掉。</p>

<pre><code>set_markup(markup)
</code></pre>

<p>这个是好东西，可以让你的 Label 显示更加丰富，通过该方法让 Label 的内容支持标记输出，其中的标记必须符合 Pango 的文本标记语言，如, &amp; 字符都要用 &lt; > &amp;amp 来替换。下面的完整例子中会用到。</p>

<pre><code>set_selectable(selectable)
</code></pre>

<p>这个方法设置文本内容是否可选择，<em>selectable </em>默认是 False，即不可选，为 Ture 时则可以供用户选择用户复制粘贴。</p>

<pre><code>set_text(text)
</code></pre>

<p>这个就不用多说了，看它就知道是干嘛的啦，使用它可以随时更改 Label 的内容。</p>

<p>好的，我们现在汇总一下看一个比较长的例子，上图先，呵呵：</p>

<p><img src="http://i.imgur.com/4o88f.png" title="label_example" alt="" /></p>

<p>这个例子包含了上面我讲到的常用方法，和一些 Label 的用法，看看完整的源代码和 Label 的内容你就懂啦~</p>

<p>完整代码：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Label Example
# PyGObject Study Notes By DawnDIY
# http://dawndiy.com

from gi.repository import Gtk

class LabelWindow(Gtk.Window):

    def __init__(self):
        Gtk.Window.__init__(self, title="Label Example")
        hbox = Gtk.Box(spacing=10)
        hbox.set_homogeneous(False)
        vbox_left = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        vbox_left.set_homogeneous(False)
        vbox_right = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        vbox_right.set_homogeneous(False)
        hbox.pack_start(vbox_left, True, True, 0)
        hbox.pack_start(vbox_right, True, True, 0)
        label = Gtk.Label("这是一个普通 label")
        vbox_left.pack_start(label, True, True, 0)
        label = Gtk.Label()
        label.set_text("这是一个左对齐的 label。n包含多行。")
        label.set_justify(Gtk.Justification.LEFT)
        vbox_left.pack_start(label, True, True, 0)
        label = Gtk.Label("这是一个右对齐的 label。n包含多行。")
        label.set_justify(Gtk.Justification.RIGHT)
        vbox_left.pack_start(label, True, True, 0)
        label = Gtk.Label("这是一个多行显示的 label 示例。它"
                            "不是占据所有能容纳下它的"
                            "宽度，而是自动的换行调整适应。n"
                            "并且它支持多段落正确的显示，"
                            "正确的补充额外的空间。")
        label.set_line_wrap(True)
        vbox_right.pack_start(label, True, True, 0)
        label = Gtk.Label("这是一个多行显示的 label 示例，填充式 label 。"
                            "它会占据所有能容纳下它的宽度。 "
                            "好，来几个句子证明我的说法。"
                            "这又是一个句子。又来一个句子，巴拉巴拉巴拉。n"
                            "这是一个新段落~n"
                            "好吧，这又是一个扯淡的段落，扯点"
                            "什么呢？元芳，你怎么看啊？呵呵~")
        label.set_line_wrap(True)
        label.set_justify(Gtk.Justification.FILL)
        vbox_right.pack_start(label, True, True, 0)
        label = Gtk.Label()
        label.set_markup("文本内容可以 小, 大, "
                            "粗体, 斜体 甚至可以是超链接 "
                            " 网络.")
        label.set_line_wrap(True)
        vbox_left.pack_start(label, True, True, 0)
        label = Gtk.Label.new_with_mnemonic("按下 Alt   P 来选择右边的按钮 (_P)")
        vbox_left.pack_start(label, True, True, 0)
        label.set_selectable(True)
        button = Gtk.Button(label="点一下试一试")
        label.set_mnemonic_widget(button)
        vbox_right.pack_start(button, True, True, 0)
        self.add(hbox)

window = LabelWindow()
window.connect("delete-event", Gtk.main_quit)
window.show_all()
Gtk.main()
</code></pre>

<p>好啦~ Label 挺简单的。。。 用好 mark 会表现的更出色的。 See you next time~</p>

<p>现在开始，之前的代码都传到 github 上去了。<br/>
文中的例子在这里：  </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PyGObject 学习笔记(8)-消息对话框]]></title>
    <link href="http://dawndiy.github.com/archives/378"/>
    <updated>2012-10-19T00:00:00+08:00</updated>
    <id>http://dawndiy.github.com/archives/pygobject-study-notes-8-message-dialog</id>
    <content type="html"><![CDATA[<h1></h1>

<p>写在前面，先扯点无聊的。这几天回家才有时间用电脑，刚好昨天升级了一下 Ubuntu 12.10 。然后当然也要更新一下学习笔记，学习在于坚持嘛~ 可能发现标题不同了，不错，我在前几天谈到我的学习心得和经历让我做出了选择，一定要向前，用GTK 3 所以选择PyGObject。可以看我写的<a href="http://www.dawndiy.com/archives/373" title="PyGTK or PyGObject">《PyGtk or PyGObject》</a>，也扯了一些有的没的。</p>

<p>好了，正题开始，今天在一点点的码自己的项目的时候要用到一个很重要的东西，那就是“消息对话框”，即 Message Dialog 。这个是什么了，如果你不知道那就快回火星吧！上图！</p>

<p><img src="http://i.imgur.com/u9Xjl.png" title="Info_message_dialog" alt="" /></p>

<p>对，就是上面这个图，你见过吧。消息对话框在程序中随处可见，他的作用就是提示或弹出一个信息让用户得知，所以消息对话框在交互方面和用户体验方面也是挺重要的。</p>

<p>在GTK 3中，构建消息对话框的类是<strong>MessageDialog</strong>。下面来看一下这个类：</p>

<pre><code>class Gtk.MessageDialog(parent=None, flags=0, type=Gtk.MESSAGE_INFO, buttons=Gtk.BUTTONS_NONE, message_format=None)
</code></pre>

<p>  <strong><code>parent</code></strong> :</p>

<p>父控件，一般是窗体</p>

<p><strong><code>flags</code></strong> :</p>

<p>对话框标识，可以是 Gtk.DialogFlags.MODAL，<code>Gtk.DIALOG_DESTROY_WITH_PARENT</code> 或 0</p>

<p><strong><code>type</code></strong> :</p>

<p>消息的类型，可以是 <code>Gtk.MESSAGE_INFO</code>, <code>Gtk.MESSAGE_WARNING</code>, <code>Gtk.MESSAGE_QUESTION</code> 或<code>Gtk.MESSAGE_ERROR</code>.</p>

<p><strong><code>buttons</code></strong> :</p>

<p>可以使用预定义的按钮： <code>Gtk.BUTTONS_NONE</code>, <code>Gtk.BUTTONS_OK</code>, <code>Gtk.BUTTONS_CLOSE</code>, <code>Gtk.BUTTONS_CANCEL</code>, <code>Gtk.BUTTONS_YES_NO</code>, <code>Gtk.BUTTONS_OK_CANCEL 等
</code></p>

<p><strong><code>message_format</code></strong> :</p>

<p>消息的内容</p>

<p><em>Returns</em> :</p>

<p> <code>G``tk.MessageDialog</code></p>

<p>上面就是构造消息对话框的 MessageDialog 类啦。</p>

<p>现在看一下我们最上面那个图的代码是怎么样的：</p>

<pre><code>dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.INFO,Gtk.ButtonsType.OK, "这是一个信息消息对话框")
dialog.format_secondary_text("这里是副文本用于说明信息。")
dialog.run()
dialog.destroy()
</code></pre>

<p>这是一个消息对话框的部分代码。是不是很简单，然而上面多了几个函数下面解释：</p>

<pre><code>dialog.format_secondary_text("这里是副文本用于说明信息。")
</code></pre>

<p>这个看图也知道啊，就是现实在下面的副文本，可以用来显示解释性文字。</p>

<pre><code>dialog.run()
dialog.destroy()
</code></pre>

<p>run执行后，对话框就会显示了，这时候对话框不会马上去执行后面的destroy来销毁，而是等待我们的一个按键响应再来销毁，所以这就是消息对话框有按钮的原因了。</p>

<p>上面的例子我们没有或得到按键响应，其实我们的按键响应就是由 <strong>dialog.run()</strong> 来返回的，所以中断在它这里嘛~那我们再看一个能获取按键的例子，惯例，上图先：</p>

<p><img src="http://i.imgur.com/0qnC7.png" title="question_message_dialog" alt="" /></p>

<p>看吧，这样的消息对话框就有两个按钮分别让你选择。看下局部代码：</p>

<pre><code>dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.QUESTION, Gtk.ButtonsType.YES_NO, "这是一个询问消息对话框")
dialog.format_secondary_text("这里是副文本用于说明信息。")
response = dialog.run()
if response == Gtk.ResponseType.YES:
    print("YES button is clicked")
elif response == Gtk.ResponseType.NO:
    print("NO button is clicked")
dialog.destroy()
</code></pre>

<p>看到代码中我们定义了一个名为 response 的变量来接受 dialog.run() 的返回，然后再做出判断分别处理就OK啦。。。</p>

<p>好了，差不多就这些吧~大家可以试一试，我把写好的一个完整的 Demo 贴出来：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*
# MessageDialog
# PyGtk Study Notes By DawnDIY
# http://www.dawndiy.com 

from gi.repository import Gtk

class MessageDialogWindow(Gtk.Window):

    def __init__(self):
        Gtk.Window.__init__(self, title="MessageDialog Example")

        box = Gtk.Box(spacing=6)
        self.add(box)

        button1 = Gtk.Button("信息")
        button1.connect("clicked", self.on_info_clicked)
        box.add(button1)

        button2 = Gtk.Button("错误")
        button2.connect("clicked", self.on_error_clicked)
        box.add(button2)

        button3 = Gtk.Button("警告")
        button3.connect("clicked", self.on_warn_clicked)
        box.add(button3)

        button4 = Gtk.Button("询问")
        button4.connect("clicked", self.on_question_clicked)
        box.add(button4)

    def on_info_clicked(self, widget):
        dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.INFO,
        Gtk.ButtonsType.OK, "这是一个信息消息对话框")
        dialog.format_secondary_text(
        "这里是副文本用于说明信息。")
        dialog.run()
        print "INFO dialog closed"

        dialog.destroy()

    def on_error_clicked(self, widget):
        dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.ERROR,
        Gtk.ButtonsType.CANCEL, "这是一个错误消息对话框")
        dialog.format_secondary_text("这里是副文本用于说明信息。")
        dialog.run()
        print "ERROR dialog closed"

        dialog.destroy()

    def on_warn_clicked(self, widget):
        dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.WARNING,
        Gtk.ButtonsType.OK_CANCEL, "这是一个警告消息对话框")
        dialog.format_secondary_text(
        "这里是副文本用于说明信息。")
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            print "OK button is clicked"
        elif response == Gtk.ResponseType.CANCEL:
            print "CANCEL button is clicked"

        dialog.destroy()

    def on_question_clicked(self, widget):
        dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.QUESTION,
        Gtk.ButtonsType.YES_NO, "这是一个询问消息对话框")
        dialog.format_secondary_text(
        "这里是副文本用于说明信息。")
        response = dialog.run()
        if response == Gtk.ResponseType.YES:
            print "YES button is clicked"
        elif response == Gtk.ResponseType.NO:
            print "NO button is clicked"

        dialog.destroy()

win = MessageDialogWindow()
win.connect("delete-event", Gtk.main_quit)
win.show_all()
Gtk.main()
</code></pre>

<p>效果自己去运行就知道了<del>OK~最近好忙啊，好不容易偷个懒上下网</del>下回继续…….</p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PyGtk学习笔记(7)–工具栏]]></title>
    <link href="http://dawndiy.github.com/archives/336"/>
    <updated>2012-09-20T00:00:00+08:00</updated>
    <id>http://dawndiy.github.com/archives/pygtk-study-notes-7-toolbar</id>
    <content type="html"><![CDATA[<h1></h1>

<p>在前面的Gtk学习中我们构造界面用到 Menu 菜单，菜单当然是让我们能方便的选择某一项功能，但是如果一个我们经常用到的菜单项在二级菜单下面，或者更深，这样一来就显得非常不方便啦。所以我们又有了更显而易见的控件– Toolbar （工具栏）。是的，工具栏通常把我们经常使用的按钮及其功能列出在一栏上面，这样就可以轻松通过鼠标的一次点击即可。就像IE、Firefox的前进和后退、地址栏、刷新等，这几个都是我们浏览网页最常用的几个功能，所以这写浏览器也会将这几个按钮列出在一栏里面供快捷使用。所以，如果你的软件功能繁多，但是想为用户提供几个常用到的快捷按钮，那就使用 Toolbar 吧。</p>

<h2>一.介绍</h2>

<p>一个简单的 Toolbar 就是这样的，如下图：[![][2]][2]</p>

<p>上面的 <strong>工具栏</strong> 中包含了4个按钮和一个分隔符，并且倒数第二个按钮是灰色的，不可用状态。OK，了解了上面的 Toolbar 长什么样，接下来我们就来实现它。</p>

<h2>二.Toolbar（工具栏）</h2>

<h3>Toolbar的继承关系：</h3>

<pre><code>-- gobject.GObject
   -- gtk.Object
     -- gtk.Widget
       -- gtk.Container
         -- gtk.Toolbar
</code></pre>

<h3>Toolbar类的概要：</h3>

<pre><code>class gtk.Toolbar(gtk.Container):
    gtk.Toolbar()

    def insert(item, pos)

    def get_item_index(item)

    def get_n_items()

    def get_nth_item(n)

    def get_drop_index(x, y)

    def set_drop_highlight_item(tool_item, index)

    def set_show_arrow(show_arrow)

    def get_show_arrow()

    def get_relief_style()

    def append_item(text, tooltip_text, tooltip_private_text, icon, callback, user_data=None)

    def prepend_item(text, tooltip_text, tooltip_private_text, icon, callback, user_data)

    def insert_item(text, tooltip_text, tooltip_private_text, icon, callback, user_data, position)

    def insert_stock(stock_id, tooltip_text, tooltip_private_text, callback, user_data, position)

    def append_space()

    def prepend_space()

    def insert_space(position)

    def remove_space(position)

    def append_element(type, widget, text, tooltip_text, tooltip_private_text, icon, callback, user_data)

    def prepend_element(type, widget, text, tooltip_text, tooltip_private_text, icon, callback, user_data)

    def insert_element(type, widget, text, tooltip_text, tooltip_private_text, icon, callback, user_data, position)

    def append_widget(widget, tooltip_text, tooltip_private_text)

    def prepend_widget(widget, tooltip_text, tooltip_private_text)

    def insert_widget(widget, tooltip_text, tooltip_private_text, position)

    def set_orientation(orientation)

    def set_style(style)

    def set_icon_size(icon_size)

    def set_tooltips(enable)

    def unset_style()

    def unset_icon_size()

    def get_orientation()

    def get_style()

    def get_icon_size()

    def get_tooltips()
</code></pre>

<h3> 构造方法：</h3>

<pre><code>gtk.Toolbar()
</code></pre>

<p><em>Returns</em> :</p>

<p>一个新的 Toolbar （工具栏）对象</p>

<h3>常用方法：</h3>

<h3>gtk.Toolbar.insert</h3>

<pre><code>def insert(item, pos)
</code></pre>

<p>  <strong><code>item</code></strong> :</p>

<p>一个 <code>gtk.ToolItem</code> 对象</p>

<p><strong><code>pos</code></strong> :</p>

<p>新项目的位置（0，1，2 …）</p>

<p><strong>注：</strong><br/>
这个方法在PyGTK 2.4以及以上版本才可用。</p>

<p>通过 insert() 方法可以在工具栏中添加 ToolItem ，用 pos 来确定其位置，如果 pos 为0，则表示该 Item 在工具栏的起始位置。</p>

<h3>gtk.Toolbar.set_style``</h3>

<pre><code>def set_style(style)
</code></pre>

<p><strong><code>style</code></strong> :</p>

<p>样式，包括：  <code>gtk.TOOLBAR_ICONS</code> （仅图标）, <code>gtk.TOOLBAR_TEXT</code>（仅文字）, <code>gtk.TOOLBAR_BOTH（全部）</code> or <code>gtk.TOOLBAR_BOTH_HORIZ（水平全部）</code></p>

<p>通过过 <code>set_style</code>() 方法，我们可以为 Toolbar 设置显示样式。</p>

<h3>gtk.Toolbar.set_icon_size</h3>

<pre><code>def set_icon_size(icon_size)
</code></pre>

<p>  <strong><code>icon_size</code></strong> :</p>

<p>图标的尺寸。``</p>

<p>通过 <code>set_icon_size</code>() 方法可以设置显示在 Toolbar 上的图标的尺寸。icon_size 的值如下：</p>

<ul>
<li><code>gtk.ICON_SIZE_MENU</code></li>
<li><code>gtk.ICON_SIZE_SMALL_TOOLBAR</code></li>
<li><code>gtk.ICON_SIZE_LARGE_TOOLBAR</code></li>
<li><code>gtk.ICON_SIZE_BUTTON</code></li>
<li><code>gtk.ICON_SIZE_DND</code>, or</li>
<li><code>gtk.ICON_SIZE_DIALOG</code></li>
</ul>


<h2>三.完整代码</h2>

<p>了解了上面的基本方法，我们就可以看实现前面的图的完整代码啦。</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*

# Toolbar
# PyGtk Study Notes By DawnDIY
# http://www.dawndiy.com

import pygtk
pygtk.require('2.0')
import gtk

class Toolbar:
    def __init__(self):
        self.win = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.win.set_title("Toolbar")
        self.win.set_size_request(300,250)
        self.win.set_position(gtk.WIN_POS_CENTER)

        toolbar = gtk.Toolbar()
        #工具栏仅显示图标
        toolbar.set_style(gtk.TOOLBAR_ICONS)

        #工具栏图标的尺寸
        toolbar.set_icon_size(gtk.ICON_SIZE_LARGE_TOOLBAR) 

        #新建工具栏按钮
        newtb = gtk.ToolButton(gtk.STOCK_NEW)
        opentb = gtk.ToolButton(gtk.STOCK_OPEN)
        sep = gtk.SeparatorToolItem()  #工具栏的分隔符
        closetb = gtk.ToolButton(gtk.STOCK_CLOSE)
        exittb = gtk.ToolButton(gtk.STOCK_QUIT)

        exittb.connect("clicked", gtk.main_quit)

        #设置CLOSE按钮不可用
        closetb.set_sensitive(False)

        #添加工具栏按钮
        toolbar.insert(newtb, 0)
        toolbar.insert(opentb, 1)
        toolbar.insert(sep, 2)
        toolbar.insert(closetb, 3)
        toolbar.insert(exittb, 4)

        vbox = gtk.VBox()
        vbox.pack_start(toolbar, False, False, 0)
        self.win.add(vbox)

        self.win.connect("destroy", gtk.main_quit)
        self.win.show_all()

if __name__ == "__main__":
    toolbar = Toolbar()
    gtk.main()
</code></pre>

<p>按照我在代码中给出的注释就很容易懂啦。然后动手改一改 icon_size 、style 等等，你会找到你想要的效果的！打完手工，待续。。。。。。</p>

<p> </p>

<p> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PyGtk学习笔记(6)–菜单]]></title>
    <link href="http://dawndiy.github.com/archives/290"/>
    <updated>2012-08-24T00:00:00+08:00</updated>
    <id>http://dawndiy.github.com/archives/pygtk-study-notes-6-menu</id>
    <content type="html"><![CDATA[<h1></h1>

<p>前面一直都在讲布局，布局学的差不多了，使用前面讲的所有布局管理已经可以设计出复杂的UI了。那么接下来来学习一下GUI程序中最常用的控件之一——菜单。</p>

<h2>1.介绍</h2>

<p>菜单栏(Menubar)是GTK中使用最多的控件之一，在菜单栏上(Menubar)上我们可以添加各式各样的菜单(Menu)和菜单项(MenuItem)。其中菜单项大致分为这几种：普通菜单项(MenuItem)、带图标的菜单项(ImageMenuItem)、带复选框的菜单项(CheckMenuItem)、分级菜单项 和 分割线(SeparatorMenuItem)。</p>

<p>先上一张图，看一看一个最普通的菜单栏：</p>

<p>[![][2]][2]</p>

<p>上面图就是一个普通的菜单栏，我们在菜单栏上面设置了四个菜单，接下来就分别详细介绍一下常用的几种菜单项。</p>

<h2>2.普通菜单</h2>

<p>普通菜单就是形式只有文字的最基本菜单，如图：</p>

<p>[![][3]][3]</p>

<p>如图，我们在菜单栏上设置了一个File1菜单，然后我们在File1下设置了3个菜单项和一个分割线。这就是一个最基本的菜单了。下面我们来看看它的代码。</p>

<p><strong>部分代码：</strong></p>

<pre><code>Mb = gtk.MenuBar()

        # 普通菜单
        filemenu = gtk.Menu()
        filem = gtk.MenuItem("File_1")
        filem.set_submenu(filemenu)

        new = gtk.MenuItem("New")
        filemenu.append(new)

        open = gtk.MenuItem("Open")
        filemenu.append(open)

        sep = gtk.SeparatorMenuItem()
        filemenu.append(sep)

        exit = gtk.MenuItem("Exit")
        exit.connect("activate", gtk.main_quit)
        filemenu.append(exit)

        Mb.append(filem)
</code></pre>

<p>如上面代码 首先新建一个菜单栏(MenuBar)</p>

<pre><code>filemenu = gtk.Menu()
</code></pre>

<p>接下来要设置一个显示在菜单栏上的菜单(Menu)和菜单项(MenuItem)</p>

<pre><code>filemenu = gtk.Menu()  # 菜单
filem = gtk.MenuItem("File_1")   # 菜单项，并添加快捷键(ALT 1)
filem.set_submenu(filemenu)    # 将菜单项设置到菜单上，显示在菜单栏上
</code></pre>

<p>然后我们就要为这个菜单添加更多的菜单项了</p>

<pre><code>new = gtk.MenuItem("New")
filemenu.append(new)   # 把菜单项添加到菜单下

open = gtk.MenuItem("Open")
filemenu.append(open)
</code></pre>

<p>添加了菜单项，我们的目的当然是要使得点击菜单能够<strong>触发事件</strong>，那么我们就可以用connect</p>

<pre><code>exit = gtk.MenuItem("Exit")
exit.connect("activate", gtk.main_quit)   # 为exit菜单项添加事件
filemenu.append(exit)
</code></pre>

<p>当然，为了很好的把菜单项分类，我们可以使用分割线</p>

<pre><code>sep = gtk.SeparatorMenuItem()
filemenu.append(sep)
</code></pre>

<p>一个最普通的菜单就是这样的~</p>

<h2>3.带图标的菜单</h2>

<p>在GUI程序里，图标往往给人带来请切感，也使得菜单更加美观。惯例，先上个图：</p>

<p><a href="http://developer.gnome.org/pygtk/stable/gtk-stock-items.html" title="Gtk Stock Items"><img src="http://developer.gnome.org/pygtk/stable/gtk-stock-items.html" title="Gtk Stock Items" alt="" /></a></p>

<p>这些丰富的图标都是GTK自带的，GTK为菜单、按钮、工具栏等等都提供了一套原生的图标，所以可以很方便的使用。下面我们来看一下带图标的菜单是如何用代码实现的。</p>

<p><strong>部分代码：</strong></p>

<pre><code>Mb = gtk.MenuBar()
        # 带图标的菜单
        imagemenu = gtk.Menu()
        filei = gtk.MenuItem("File_2")
        filei.set_submenu(imagemenu)

        newi = gtk.ImageMenuItem(gtk.STOCK_NEW)
        newi.set_label("New")
        imagemenu.append(newi)

        openi = gtk.ImageMenuItem(gtk.STOCK_OPEN)
        openi.set_label("Open")
        imagemenu.append(openi)

        sep2 = gtk.SeparatorMenuItem()
        imagemenu.append(sep2)

        exiti = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        exiti.set_label("Exit")
        exiti.connect("activate", gtk.main_quit)
        imagemenu.append(exiti)

                Mb.append(filei)
</code></pre>

<p>看到代码，我们发现其实就是使用了 <strong>gtk.ImageMenuItem</strong> 这个函数。</p>

<p>首先我们新建带图标的菜单项，并且给它设置图标</p>

<pre><code>newi = gtk.ImageMenuItem(gtk.STOCK_NEW)
</code></pre>

<p>其中的 <strong>gtk.STOCK_NEW</strong> 是GTK预设的 NEW 图标。<strong>有关所有的GTK预设的 STOCK 请看这里：<a href="http://developer.gnome.org/pygtk/stable/gtk-stock-items.html" title="Gtk Stock Items">Stock Items</a></strong></p>

<p>然后是设置菜单项显示的文字(标签)，并添加至菜单中</p>

<pre><code>newi.set_label("New")
imagemenu.append(newi)
</code></pre>

<p>这就是带图标的菜单，让你的菜单更美观~</p>

<h2>4.带复选框的菜单</h2>

<p>在GUI程序中常常用菜单选项来对程序进行设置，那么带复选框的菜单就可以完成这样的功能，先上图：</p>

<p>[![][6]][6]</p>

<p>如图，New选项目前是勾选上的，其他的都没有勾选，这样的菜单我们就能够拿来当设置选项来用。下面看一下代码有什么不同。</p>

<p><strong>部分代码：</strong></p>

<pre><code>Mb = gtk.MenuBar()
        # 带复选框的菜单项
        checkmenu = gtk.Menu()
        filec = gtk.MenuItem("File_3")
        filec.set_submenu(checkmenu)

        newc = gtk.CheckMenuItem("New")
        newc.set_active(True)       # 激活复选框
        checkmenu.append(newc)

        openc = gtk.CheckMenuItem("Open")
        openc.set_active(False) 
        checkmenu.append(openc)

        sep3 = gtk.SeparatorMenuItem()
        checkmenu.append(sep3)

        exitc = gtk.CheckMenuItem("Exit")
        checkmenu.append(exitc)

        Mb.append(filec)
</code></pre>

<p>如上面的代码，我们通过以下代码来新建菜单项，这就是和别的菜单项不同的地方</p>

<pre><code>newc = gtk.CheckMenuItem("New")
</code></pre>

<p>接下来是设置<strong>复选框的状态</strong>，默认复选框是没有被选中的。</p>

<pre><code>newc.set_active(True) # 激活复选框
</code></pre>

<p>同样，选中后触发的实际依然是用<strong>connect</strong>。</p>

<h2>5.分级的菜单项</h2>

<p>在菜单下的菜单项非常多的时候我们往往使用分割线来把不同类型的菜单项分隔开来，但是更多的菜单项的时候就会显得一个菜单下面老长一条的，显得没有调理，这时候我们可以使用分级菜单，按照菜单项分类，把同一类的归于一个菜单项的子项。这样就既有调理，又美观。看一个分级菜单的图先(图没截好，但你懂得~ ^.<sup>)。</sup></p>

<p>[![][7]][7]</p>

<p>其实分级的菜单也就是菜单一层套一层实现的。</p>

<p><strong>部分代码：</strong></p>

<pre><code># 多级菜单
        topmenu = gtk.Menu()    
        files = gtk.MenuItem("File_4")
        files.set_submenu(topmenu)

        submenu = gtk.Menu()    # 上层

        news = gtk.MenuItem("New")
        news.set_submenu(submenu)

        sub1 = gtk.MenuItem("Sub1")     # 子层
        sub2 = gtk.MenuItem("Sub2")
        sub3 = gtk.MenuItem("Sub3")

        submenu.append(sub1)
        submenu.append(sub2)
        submenu.append(sub3)

        topmenu.append(news)

        self.append(filem)
        self.append(filei)
        self.append(filec)
        self.append(files)
</code></pre>

<p>在代码中我们能够发现的是，其实就是在普通的菜单的基础上再套了一层菜单。通俗的讲，首先我们建立菜单，然后将菜单项添加至菜单，随后再一个个向其中添加菜单项(MenuItem)，然后分级菜单在这里不同的是，本要一个个添加菜单项(MenuItem)的时候这里添加的确实菜单(Menu)，然后在向这个子菜单(Menu)添加菜单项(MenuItem)，这样就达到了多级菜单的效果了。</p>

<h2>6.菜单快捷键</h2>

<p>在前面普通菜单的地方，我们提到了菜单的快捷键，在菜单项标签设置的时候，在字母或数字前加“_”即可，这样的话，在当前活动窗口按下 <strong>ALT</strong> 键不放，下划线就会出现，这时你再按下相应的字母和数字就能激活该菜单了。设置如下：</p>

<pre><code>files = gtk.MenuItem("File_4")
</code></pre>

<p>值得注意的是，要是把这种下划线的快捷方式用在菜单里面的每个菜单项也能用吗？答案是当然能用，但是不同的是，你首先要使用 <strong>ALT 字母</strong> 先激活打开菜单，然后再 <strong>按下相应字母</strong> 才能选中该菜单项，<strong>而不能</strong>在当前窗口之间按 <strong>ALT 字母</strong> 来触发。</p>

<p>那有什么方法能够是的在整个窗口全局的情况下，不用进入菜单直接按快捷方式就能完成点击某个菜单子项的功能吗？答案依然是可以的，使用<strong> add_accelerator</strong> 这个函数就能实现。</p>

<p>先看效果图：</p>

<p>[![][8]][8]</p>

<p>如图我们设置的快捷键是 <strong>Ctrl Q</strong> ,同时Exit的标签我们也用“_Exit”设置过了，放在一起对比一下，下面是<strong>该例子的完整代码：</strong></p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*

# Menu_accelerator
# PyGtk Study Notes By DawnDIY
# http://www.dawndiy.com

import pygtk
pygtk.require('2.0')
import gtk

class MenuTest(gtk.Window):
    def __init__(self):
        super(MenuTest, self).__init__()

        self.set_title("Menu")
        self.set_size_request(300,250)
        self.set_position(gtk.WIN_POS_CENTER)

        mb = gtk.MenuBar()

        filemenu = gtk.Menu()
        filem = gtk.MenuItem("_File")
        filem.set_submenu(filemenu)

        agr = gtk.AccelGroup()
        self.add_accel_group(agr)

        exit = gtk.MenuItem("_Exit", agr)

        key, mod = gtk.accelerator_parse("Q")
        exit.add_accelerator("activate", agr, key, mod, gtk.ACCEL_VISIBLE)
        exit.connect("activate", gtk.main_quit)
        filemenu.append(exit)

        mb.append(filem)

        vbox = gtk.VBox(False, 2)
        vbox.pack_start(mb, False, False, 0)

        self.add(vbox)
        self.connect("destroy", gtk.main_quit)
        self.show_all()

if __name__ == "__main__":
    mt = MenuTest()
    gtk.main()
</code></pre>

<p>看到代码中，比我们前面讲的多了一些东西。</p>

<p>为了使用快捷键,我们先创建了一个全局的AccelGroup对象,它将在之后被使用</p>

<pre><code>agr = gtk.AccelGroup()
self.add_accel_group(agr)
</code></pre>

<p>在菜单项建立的时候，添加该菜单项的快捷方式属于那个AccelGroup对象</p>

<pre><code>exit = gtk.MenuItem("_Exit", agr)
</code></pre>

<p>然后就是设置具体的快捷键了。</p>

<pre><code>key, mod = gtk.accelerator_parse("Q")
exit.add_accelerator("activate", agr, key, mod, gtk.ACCEL_VISIBLE)
</code></pre>

<p><strong>详细说一下几个函数:</strong></p>

<h3>gtk.accelerator_parse</h3>

<pre><code>def gtk.accelerator_parse(accelerator)
</code></pre>

<p>  <strong><code>accelerator</code></strong> :</p>

<p>一个表示快捷键的字符串</p>

<p><em>Returns</em> :</p>

<p>一个包含快捷方式的 键值 和 修饰符 的 2元组</p>

<h3>gtk.Widget.add_accelerator</h3>

<pre><code>def add_accelerator(accel_signal, accel_group, accel_key, accel_mods, accel_flags)
</code></pre>

<p>  <strong><code>accel_signal</code></strong> :</p>

<p>快捷键激活的控件信号</p>

<p><strong><code>accel_group</code></strong> :</p>

<p>控件快捷方式的组，加入它的顶层</p>

<p><strong><code>accel_key</code></strong> :</p>

<p>快捷方式的键值 如(‘q’)``</p>

<p><strong><code>accel_mods</code></strong> :</p>

<p>快捷键的修饰符</p>

<p><strong><code>accel_flags</code></strong> :</p>

<p>快捷键标识, 如 <code>gtk.ACCEL_VISIBLE</code></p>

<p>运行上面的代码后你会发现，在当前活动的窗口下，直接按 ALT E 是没有效果的，窗口不会关闭，非要先按 Alt E 激活菜单再按E键就能关闭窗口，这是第一种快捷方式。然而我们加入了第二种后，不管有没有激活菜单，直接按下 Ctrl Q 即可关闭窗口，这就是两种不同的快捷方式的设置。</p>

<h2>7.完整代码</h2>

<p><strong>下面是前面讲到的四中菜单示例的完整代码：</strong></p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*

# Menu
# PyGtk Stady Notes By DawnDIY
# http://www.dawndiy.com

import pygtk
pygtk.require('2.0')
import gtk

# 菜单条
class Mb(gtk.MenuBar):
    def __init__(self):
        super(Mb,self).__init__()

        # 普通菜单
        filemenu = gtk.Menu()
        filem = gtk.MenuItem("File_1")
        filem.set_submenu(filemenu)

        new = gtk.MenuItem("New")
        filemenu.append(new)

        open = gtk.MenuItem("Open")
        filemenu.append(open)

        sep = gtk.SeparatorMenuItem()
        filemenu.append(sep)

        exit = gtk.MenuItem("Exit")
        exit.connect("activate", gtk.main_quit)
        filemenu.append(exit)

        # 带图标的菜单
        imagemenu = gtk.Menu()
        filei = gtk.MenuItem("File_2")
        filei.set_submenu(imagemenu)

        newi = gtk.ImageMenuItem(gtk.STOCK_NEW)
        newi.set_label("New")
        imagemenu.append(newi)

        openi = gtk.ImageMenuItem(gtk.STOCK_OPEN)
        openi.set_label("Open")
        imagemenu.append(openi)

        sep2 = gtk.SeparatorMenuItem()
        imagemenu.append(sep2)

        exiti = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        exiti.set_label("Exit")
        exiti.connect("activate", gtk.main_quit)
        imagemenu.append(exiti)

        # 带复选框的菜单项
        checkmenu = gtk.Menu()
        filec = gtk.MenuItem("File_3")
        filec.set_submenu(checkmenu)

        newc = gtk.CheckMenuItem("New")
        newc.set_active(True)       # 激活复选框
        checkmenu.append(newc)

        openc = gtk.CheckMenuItem("Open")
        openc.set_active(False) 
        checkmenu.append(openc)

        sep3 = gtk.SeparatorMenuItem()
        checkmenu.append(sep3)

        exitc = gtk.CheckMenuItem("Exit")
        checkmenu.append(exitc)

        # 多级菜单
        topmenu = gtk.Menu()    
        files = gtk.MenuItem("File_4")
        files.set_submenu(topmenu)

        submenu = gtk.Menu()    # 上层

        news = gtk.MenuItem("New")
        news.set_submenu(submenu)

        sub1 = gtk.MenuItem("Sub1")     # 子层
        sub2 = gtk.MenuItem("Sub2")
        sub3 = gtk.MenuItem("Sub3")

        submenu.append(sub1)
        submenu.append(sub2)
        submenu.append(sub3)

        topmenu.append(news)

        self.append(filem)
        self.append(filei)
        self.append(filec)
        self.append(files)
class Win:
    def __init__(self):
        self.win = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.win.set_title("Menu")
        self.win.set_size_request(300,250)
        self.win.set_position(gtk.WIN_POS_CENTER)

        mb = Mb()
        vbox = gtk.VBox(False, 2)       
        vbox.pack_start(mb, False, False, 0)

        self.win.add(vbox)

        self.win.connect("destroy", gtk.main_quit)
        self.win.show_all()

if __name__ == "__main__":
    win = Win()
    gtk.main()
</code></pre>

<p>OK~菜单基本上就是这些了，今天学习到这里。。。待续。。。</p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
  </entry>
  
</feed>
