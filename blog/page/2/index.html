
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>一个人的世界</title>
    <meta name="author" content="DawnDIY">
    
	<meta name="description" content="Published on: Sep 12th, 2012 Tags: Linux   Ubuntu 12.10 越来越近了~近期 Ubuntu 12.10 默认壁纸也浮现出来了。 上图，这就是 Ubuntu 12.10 的默认壁纸。 延续着 Ubuntu 紫色和橙色的搭配，Ubuntu 12. &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="一个人的世界" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='http://fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>

    <!-- remove or comment it to disable ajaxification -->   
    <script src="/javascripts/ajaxify.js"></script>
   
    
</head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        DawnDIY
    </div>
</h1>
<br>

<ul id="social-links" style="text-align:center">
  
  <!-- GitHub -->
  <li>
  <a href="https://github.com/DawnDIY" class="github" title="Github"></a>
  </li>
  
  
  
  
  <!-- Twitter -->
  <li>
  <a href="http://www.twitter.com/DawnDIYSoft" class="twitter" title="Twitter"></a>
  </li>
  
  
  
  
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/blog/archives/index.html">Archives</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    
    <li>
    <div id="dark">
        <form method="get" action="/search.html" id="search">
            <input name="query" type="text" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>

<div id="toload">
<!-- begin toload --> 
    <div id="content" class="inner">
        


    <article class="post">
	<h2 class="title">
		
		<a href="/archives/327">
		
			Ubuntu 12.10 默认新壁纸预览~</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: 








  


<time datetime="2012-09-12T00:00:00+08:00" pubdate data-updated="true">Sep 12<span>th</span>, 2012</time></div>
      <div class="tags">Tags: 


	<a class='category' href='/blog/categories/linux/'>Linux</a>


</div>
    </div>
		<h1></h1>

<p> </p>

<p>Ubuntu 12.10 越来越近了~近期 Ubuntu 12.10 默认壁纸也浮现出来了。</p>

<p>上图，这就是 Ubuntu 12.10 的默认壁纸。</p>

<p><img src="http://i.imgur.com/GD3w6.jpg" title="Ubuntu12.10-Default-Wallpaper" alt="" /></p>

<p>延续着 Ubuntu 紫色和橙色的搭配，Ubuntu 12.10 继续使用名为“紫色沙拉”系列的壁纸，对比 Ubuntu 12.04 的壁纸，这张壁纸更显圆滑，色彩过度自然。</p>

<p>下面是一张 Ubuntu 10.04 ~12.04 的壁纸动态图：</p>

<p><img src="http://i.imgur.com/z1Eso.gif" title="Default-Wallpaper-From-Ubuntu10.04-12.04" alt="" /></p>

<p><strong><a href="http://bazaar.launchpad.net/~ubuntu-art-pkg/ubuntu-wallpapers/ubuntu/download/head:/elephantskin.jpg-20070925092320-wp63xkqaf9y3tbmp-1/warty-final-ubuntu.png">下载 Ubuntu 12.10 默认壁纸</a></strong></p>

<p><strong><a href="https://launchpad.net/ubuntu/quantal/">下载 Ubuntu 12.10 其他壁纸</a></strong></p>

		
		
	</div>

<div class="meta">
	
		<span class="comments"><a href="/archives/327/blog/page/2/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/archives/290">
		
			PyGtk学习笔记(6)–菜单</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: 








  


<time datetime="2012-08-24T00:00:00+08:00" pubdate data-updated="true">Aug 24<span>th</span>, 2012</time></div>
      <div class="tags">Tags: 


	<a class='category' href='/blog/categories/pygtk/'>PyGtk</a>, <a class='category' href='/blog/categories/python/'>Python</a>


</div>
    </div>
		<h1></h1>

<p>前面一直都在讲布局，布局学的差不多了，使用前面讲的所有布局管理已经可以设计出复杂的UI了。那么接下来来学习一下GUI程序中最常用的控件之一——菜单。</p>

<h2>1.介绍</h2>

<p>菜单栏(Menubar)是GTK中使用最多的控件之一，在菜单栏上(Menubar)上我们可以添加各式各样的菜单(Menu)和菜单项(MenuItem)。其中菜单项大致分为这几种：普通菜单项(MenuItem)、带图标的菜单项(ImageMenuItem)、带复选框的菜单项(CheckMenuItem)、分级菜单项 和 分割线(SeparatorMenuItem)。</p>

<p>先上一张图，看一看一个最普通的菜单栏：</p>

<p>[![][2]][2]</p>

<p>上面图就是一个普通的菜单栏，我们在菜单栏上面设置了四个菜单，接下来就分别详细介绍一下常用的几种菜单项。</p>

<h2>2.普通菜单</h2>

<p>普通菜单就是形式只有文字的最基本菜单，如图：</p>

<p>[![][3]][3]</p>

<p>如图，我们在菜单栏上设置了一个File1菜单，然后我们在File1下设置了3个菜单项和一个分割线。这就是一个最基本的菜单了。下面我们来看看它的代码。</p>

<p><strong>部分代码：</strong></p>

<pre><code>Mb = gtk.MenuBar()

        # 普通菜单
        filemenu = gtk.Menu()
        filem = gtk.MenuItem("File_1")
        filem.set_submenu(filemenu)

        new = gtk.MenuItem("New")
        filemenu.append(new)

        open = gtk.MenuItem("Open")
        filemenu.append(open)

        sep = gtk.SeparatorMenuItem()
        filemenu.append(sep)

        exit = gtk.MenuItem("Exit")
        exit.connect("activate", gtk.main_quit)
        filemenu.append(exit)

        Mb.append(filem)
</code></pre>

<p>如上面代码 首先新建一个菜单栏(MenuBar)</p>

<pre><code>filemenu = gtk.Menu()
</code></pre>

<p>接下来要设置一个显示在菜单栏上的菜单(Menu)和菜单项(MenuItem)</p>

<pre><code>filemenu = gtk.Menu()  # 菜单
filem = gtk.MenuItem("File_1")   # 菜单项，并添加快捷键(ALT 1)
filem.set_submenu(filemenu)    # 将菜单项设置到菜单上，显示在菜单栏上
</code></pre>

<p>然后我们就要为这个菜单添加更多的菜单项了</p>

<pre><code>new = gtk.MenuItem("New")
filemenu.append(new)   # 把菜单项添加到菜单下

open = gtk.MenuItem("Open")
filemenu.append(open)
</code></pre>

<p>添加了菜单项，我们的目的当然是要使得点击菜单能够<strong>触发事件</strong>，那么我们就可以用connect</p>

<pre><code>exit = gtk.MenuItem("Exit")
exit.connect("activate", gtk.main_quit)   # 为exit菜单项添加事件
filemenu.append(exit)
</code></pre>

<p>当然，为了很好的把菜单项分类，我们可以使用分割线</p>

<pre><code>sep = gtk.SeparatorMenuItem()
filemenu.append(sep)
</code></pre>

<p>一个最普通的菜单就是这样的~</p>

<h2>3.带图标的菜单</h2>

<p>在GUI程序里，图标往往给人带来请切感，也使得菜单更加美观。惯例，先上个图：</p>

<p><a href="http://developer.gnome.org/pygtk/stable/gtk-stock-items.html" title="Gtk Stock Items"><img src="http://developer.gnome.org/pygtk/stable/gtk-stock-items.html" title="Gtk Stock Items" alt="" /></a></p>

<p>这些丰富的图标都是GTK自带的，GTK为菜单、按钮、工具栏等等都提供了一套原生的图标，所以可以很方便的使用。下面我们来看一下带图标的菜单是如何用代码实现的。</p>

<p><strong>部分代码：</strong></p>

<pre><code>Mb = gtk.MenuBar()
        # 带图标的菜单
        imagemenu = gtk.Menu()
        filei = gtk.MenuItem("File_2")
        filei.set_submenu(imagemenu)

        newi = gtk.ImageMenuItem(gtk.STOCK_NEW)
        newi.set_label("New")
        imagemenu.append(newi)

        openi = gtk.ImageMenuItem(gtk.STOCK_OPEN)
        openi.set_label("Open")
        imagemenu.append(openi)

        sep2 = gtk.SeparatorMenuItem()
        imagemenu.append(sep2)

        exiti = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        exiti.set_label("Exit")
        exiti.connect("activate", gtk.main_quit)
        imagemenu.append(exiti)

                Mb.append(filei)
</code></pre>

<p>看到代码，我们发现其实就是使用了 <strong>gtk.ImageMenuItem</strong> 这个函数。</p>

<p>首先我们新建带图标的菜单项，并且给它设置图标</p>

<pre><code>newi = gtk.ImageMenuItem(gtk.STOCK_NEW)
</code></pre>

<p>其中的 <strong>gtk.STOCK_NEW</strong> 是GTK预设的 NEW 图标。<strong>有关所有的GTK预设的 STOCK 请看这里：<a href="http://developer.gnome.org/pygtk/stable/gtk-stock-items.html" title="Gtk Stock Items">Stock Items</a></strong></p>

<p>然后是设置菜单项显示的文字(标签)，并添加至菜单中</p>

<pre><code>newi.set_label("New")
imagemenu.append(newi)
</code></pre>

<p>这就是带图标的菜单，让你的菜单更美观~</p>

<h2>4.带复选框的菜单</h2>

<p>在GUI程序中常常用菜单选项来对程序进行设置，那么带复选框的菜单就可以完成这样的功能，先上图：</p>

<p>[![][6]][6]</p>

<p>如图，New选项目前是勾选上的，其他的都没有勾选，这样的菜单我们就能够拿来当设置选项来用。下面看一下代码有什么不同。</p>

<p><strong>部分代码：</strong></p>

<pre><code>Mb = gtk.MenuBar()
        # 带复选框的菜单项
        checkmenu = gtk.Menu()
        filec = gtk.MenuItem("File_3")
        filec.set_submenu(checkmenu)

        newc = gtk.CheckMenuItem("New")
        newc.set_active(True)       # 激活复选框
        checkmenu.append(newc)

        openc = gtk.CheckMenuItem("Open")
        openc.set_active(False) 
        checkmenu.append(openc)

        sep3 = gtk.SeparatorMenuItem()
        checkmenu.append(sep3)

        exitc = gtk.CheckMenuItem("Exit")
        checkmenu.append(exitc)

        Mb.append(filec)
</code></pre>

<p>如上面的代码，我们通过以下代码来新建菜单项，这就是和别的菜单项不同的地方</p>

<pre><code>newc = gtk.CheckMenuItem("New")
</code></pre>

<p>接下来是设置<strong>复选框的状态</strong>，默认复选框是没有被选中的。</p>

<pre><code>newc.set_active(True) # 激活复选框
</code></pre>

<p>同样，选中后触发的实际依然是用<strong>connect</strong>。</p>

<h2>5.分级的菜单项</h2>

<p>在菜单下的菜单项非常多的时候我们往往使用分割线来把不同类型的菜单项分隔开来，但是更多的菜单项的时候就会显得一个菜单下面老长一条的，显得没有调理，这时候我们可以使用分级菜单，按照菜单项分类，把同一类的归于一个菜单项的子项。这样就既有调理，又美观。看一个分级菜单的图先(图没截好，但你懂得~ ^.<sup>)。</sup></p>

<p>[![][7]][7]</p>

<p>其实分级的菜单也就是菜单一层套一层实现的。</p>

<p><strong>部分代码：</strong></p>

<pre><code># 多级菜单
        topmenu = gtk.Menu()    
        files = gtk.MenuItem("File_4")
        files.set_submenu(topmenu)

        submenu = gtk.Menu()    # 上层

        news = gtk.MenuItem("New")
        news.set_submenu(submenu)

        sub1 = gtk.MenuItem("Sub1")     # 子层
        sub2 = gtk.MenuItem("Sub2")
        sub3 = gtk.MenuItem("Sub3")

        submenu.append(sub1)
        submenu.append(sub2)
        submenu.append(sub3)

        topmenu.append(news)

        self.append(filem)
        self.append(filei)
        self.append(filec)
        self.append(files)
</code></pre>

<p>在代码中我们能够发现的是，其实就是在普通的菜单的基础上再套了一层菜单。通俗的讲，首先我们建立菜单，然后将菜单项添加至菜单，随后再一个个向其中添加菜单项(MenuItem)，然后分级菜单在这里不同的是，本要一个个添加菜单项(MenuItem)的时候这里添加的确实菜单(Menu)，然后在向这个子菜单(Menu)添加菜单项(MenuItem)，这样就达到了多级菜单的效果了。</p>

<h2>6.菜单快捷键</h2>

<p>在前面普通菜单的地方，我们提到了菜单的快捷键，在菜单项标签设置的时候，在字母或数字前加“_”即可，这样的话，在当前活动窗口按下 <strong>ALT</strong> 键不放，下划线就会出现，这时你再按下相应的字母和数字就能激活该菜单了。设置如下：</p>

<pre><code>files = gtk.MenuItem("File_4")
</code></pre>

<p>值得注意的是，要是把这种下划线的快捷方式用在菜单里面的每个菜单项也能用吗？答案是当然能用，但是不同的是，你首先要使用 <strong>ALT 字母</strong> 先激活打开菜单，然后再 <strong>按下相应字母</strong> 才能选中该菜单项，<strong>而不能</strong>在当前窗口之间按 <strong>ALT 字母</strong> 来触发。</p>

<p>那有什么方法能够是的在整个窗口全局的情况下，不用进入菜单直接按快捷方式就能完成点击某个菜单子项的功能吗？答案依然是可以的，使用<strong> add_accelerator</strong> 这个函数就能实现。</p>

<p>先看效果图：</p>

<p>[![][8]][8]</p>

<p>如图我们设置的快捷键是 <strong>Ctrl Q</strong> ,同时Exit的标签我们也用“_Exit”设置过了，放在一起对比一下，下面是<strong>该例子的完整代码：</strong></p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*

# Menu_accelerator
# PyGtk Study Notes By DawnDIY
# http://www.dawndiy.com

import pygtk
pygtk.require('2.0')
import gtk

class MenuTest(gtk.Window):
    def __init__(self):
        super(MenuTest, self).__init__()

        self.set_title("Menu")
        self.set_size_request(300,250)
        self.set_position(gtk.WIN_POS_CENTER)

        mb = gtk.MenuBar()

        filemenu = gtk.Menu()
        filem = gtk.MenuItem("_File")
        filem.set_submenu(filemenu)

        agr = gtk.AccelGroup()
        self.add_accel_group(agr)

        exit = gtk.MenuItem("_Exit", agr)

        key, mod = gtk.accelerator_parse("Q")
        exit.add_accelerator("activate", agr, key, mod, gtk.ACCEL_VISIBLE)
        exit.connect("activate", gtk.main_quit)
        filemenu.append(exit)

        mb.append(filem)

        vbox = gtk.VBox(False, 2)
        vbox.pack_start(mb, False, False, 0)

        self.add(vbox)
        self.connect("destroy", gtk.main_quit)
        self.show_all()

if __name__ == "__main__":
    mt = MenuTest()
    gtk.main()
</code></pre>

<p>看到代码中，比我们前面讲的多了一些东西。</p>

<p>为了使用快捷键,我们先创建了一个全局的AccelGroup对象,它将在之后被使用</p>

<pre><code>agr = gtk.AccelGroup()
self.add_accel_group(agr)
</code></pre>

<p>在菜单项建立的时候，添加该菜单项的快捷方式属于那个AccelGroup对象</p>

<pre><code>exit = gtk.MenuItem("_Exit", agr)
</code></pre>

<p>然后就是设置具体的快捷键了。</p>

<pre><code>key, mod = gtk.accelerator_parse("Q")
exit.add_accelerator("activate", agr, key, mod, gtk.ACCEL_VISIBLE)
</code></pre>

<p><strong>详细说一下几个函数:</strong></p>

<h3>gtk.accelerator_parse</h3>

<pre><code>def gtk.accelerator_parse(accelerator)
</code></pre>

<p>  <strong><code>accelerator</code></strong> :</p>

<p>一个表示快捷键的字符串</p>

<p><em>Returns</em> :</p>

<p>一个包含快捷方式的 键值 和 修饰符 的 2元组</p>

<h3>gtk.Widget.add_accelerator</h3>

<pre><code>def add_accelerator(accel_signal, accel_group, accel_key, accel_mods, accel_flags)
</code></pre>

<p>  <strong><code>accel_signal</code></strong> :</p>

<p>快捷键激活的控件信号</p>

<p><strong><code>accel_group</code></strong> :</p>

<p>控件快捷方式的组，加入它的顶层</p>

<p><strong><code>accel_key</code></strong> :</p>

<p>快捷方式的键值 如(‘q’)&#8220;</p>

<p><strong><code>accel_mods</code></strong> :</p>

<p>快捷键的修饰符</p>

<p><strong><code>accel_flags</code></strong> :</p>

<p>快捷键标识, 如 <code>gtk.ACCEL_VISIBLE</code></p>

<p>运行上面的代码后你会发现，在当前活动的窗口下，直接按 ALT E 是没有效果的，窗口不会关闭，非要先按 Alt E 激活菜单再按E键就能关闭窗口，这是第一种快捷方式。然而我们加入了第二种后，不管有没有激活菜单，直接按下 Ctrl Q 即可关闭窗口，这就是两种不同的快捷方式的设置。</p>

<h2>7.完整代码</h2>

<p><strong>下面是前面讲到的四中菜单示例的完整代码：</strong></p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*

# Menu
# PyGtk Stady Notes By DawnDIY
# http://www.dawndiy.com

import pygtk
pygtk.require('2.0')
import gtk

# 菜单条
class Mb(gtk.MenuBar):
    def __init__(self):
        super(Mb,self).__init__()

        # 普通菜单
        filemenu = gtk.Menu()
        filem = gtk.MenuItem("File_1")
        filem.set_submenu(filemenu)

        new = gtk.MenuItem("New")
        filemenu.append(new)

        open = gtk.MenuItem("Open")
        filemenu.append(open)

        sep = gtk.SeparatorMenuItem()
        filemenu.append(sep)

        exit = gtk.MenuItem("Exit")
        exit.connect("activate", gtk.main_quit)
        filemenu.append(exit)

        # 带图标的菜单
        imagemenu = gtk.Menu()
        filei = gtk.MenuItem("File_2")
        filei.set_submenu(imagemenu)

        newi = gtk.ImageMenuItem(gtk.STOCK_NEW)
        newi.set_label("New")
        imagemenu.append(newi)

        openi = gtk.ImageMenuItem(gtk.STOCK_OPEN)
        openi.set_label("Open")
        imagemenu.append(openi)

        sep2 = gtk.SeparatorMenuItem()
        imagemenu.append(sep2)

        exiti = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        exiti.set_label("Exit")
        exiti.connect("activate", gtk.main_quit)
        imagemenu.append(exiti)

        # 带复选框的菜单项
        checkmenu = gtk.Menu()
        filec = gtk.MenuItem("File_3")
        filec.set_submenu(checkmenu)

        newc = gtk.CheckMenuItem("New")
        newc.set_active(True)       # 激活复选框
        checkmenu.append(newc)

        openc = gtk.CheckMenuItem("Open")
        openc.set_active(False) 
        checkmenu.append(openc)

        sep3 = gtk.SeparatorMenuItem()
        checkmenu.append(sep3)

        exitc = gtk.CheckMenuItem("Exit")
        checkmenu.append(exitc)

        # 多级菜单
        topmenu = gtk.Menu()    
        files = gtk.MenuItem("File_4")
        files.set_submenu(topmenu)

        submenu = gtk.Menu()    # 上层

        news = gtk.MenuItem("New")
        news.set_submenu(submenu)

        sub1 = gtk.MenuItem("Sub1")     # 子层
        sub2 = gtk.MenuItem("Sub2")
        sub3 = gtk.MenuItem("Sub3")

        submenu.append(sub1)
        submenu.append(sub2)
        submenu.append(sub3)

        topmenu.append(news)

        self.append(filem)
        self.append(filei)
        self.append(filec)
        self.append(files)
class Win:
    def __init__(self):
        self.win = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.win.set_title("Menu")
        self.win.set_size_request(300,250)
        self.win.set_position(gtk.WIN_POS_CENTER)

        mb = Mb()
        vbox = gtk.VBox(False, 2)       
        vbox.pack_start(mb, False, False, 0)

        self.win.add(vbox)

        self.win.connect("destroy", gtk.main_quit)
        self.win.show_all()

if __name__ == "__main__":
    win = Win()
    gtk.main()
</code></pre>

<p>OK~菜单基本上就是这些了，今天学习到这里。。。待续。。。</p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

		
		
	</div>

<div class="meta">
	
		<span class="comments"><a href="/archives/290/blog/page/2/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/archives/229">
		
			Android 手机上安装并运行 Ubuntu 12.04</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: 








  


<time datetime="2012-08-16T00:00:00+08:00" pubdate data-updated="true">Aug 16<span>th</span>, 2012</time></div>
      <div class="tags">Tags: 


	<a class='category' href='/blog/categories/android/'>Android</a>


</div>
    </div>
		<h1></h1>

<ul>
<li>ubuntu.sh脚本的原地址变动了，导致下载不了，现在更新了网盘地址。小技巧：遇到一些下载失效的时候可以试一试p2p下载工具（如 easyMule、迅雷等）试一试，说不定有人分享过~*<br/>
————————————————————————————-</li>
</ul>


<p>Android 是基于Linux内核的开源操作系统，主要用在移动设备上。当然同样是基于Linux内核的操作系统，现在支持的Android的智能手机理论来说都能运行基于Linux的操作系统，比如现在流行的发行版：Ubuntu、Fedora 等等。不仅如此，现在的智能移动设备的硬件也越来越强，更为能运行Linux系统提供了良好的硬件支持。今天<a href="http://www.dawndiy.com">DawnDIY</a>就带大家来尝试一下在 Android 手机上安装 Ubuntu 12.04 操作系统。</p>

<h2>一.效果预览</h2>

<p>先上图，解个馋~这就是安装后的效果。</p>

<p><img src="http://i.imgur.com/1O2xX.png" title="Screenshot_2012-08-16-00-50-44" alt="" /></p>

<p><img src="http://i.imgur.com/8uj3J.png" title="Screenshot_2012-08-15-01-48-46" alt="" /></p>

<p><img src="http://i.imgur.com/7PY2e.png" title="Screenshot_2012-08-16-02-13-20" alt="" /></p>

<p><img src="http://i.imgur.com/Za4Rz.jpg" title="20120815004" alt="" /></p>

<p>看到上面的图了吧，这就是安装最新的 Ubuntu 12.04 在 Android 智能机上的效果。同时因为 Unity 原生就是支持触屏设备的，所以操作方面还是可以的，只不过就是屏幕小了点而已~好了，下面我来介绍一下我的安装过程。</p>

<h2>二.配置要求</h2>

<ul>
<li>设备需要root权限，并且安装了<a href="http://zh.wikipedia.org/wiki/Busybox">BusyBox</a></li>
<li>最小 1GHz 处理器(推荐)</li>
<li>Android 系统版本 2.1 或以上</li>
<li>Android 设备需要自定义的ROM固件</li>
<li>SD卡至2.5GB (安装大映像的需要3.5GB)</li>
<li>设备需要支持WIFI (这个用于其他设备通过WIFI登录)</li>
<li>支持 Ext2 文件系统(大部分 Android 设备应该都支持)</li>
</ul>


<p><strong>我的设备</strong></p>

<ul>
<li>手机型号：Mi-One Plus</li>
<li>处理器主频：1.5GHz * 2</li>
<li>SD卡：16G class 4</li>
<li>系统ROM：MIUI_v4_2.8.10</li>
<li>BusyBox版本：1.20.2</li>
</ul>


<h2>三.需要的软件</h2>

<ul>
<li>Android Terminal Emulator (终端模拟器) ：用于运行 <a href="http://zh.wikipedia.org/wiki/Shell">shell</a> 脚本     <a href="https://play.google.com/store/apps/details?id=jackpal.androidterm">Google Play</a></li>
<li>BusyBox ：用于提供 shell 命令的支持   <a href="https://play.google.com/store/apps/details?id=stericson.busybox">Google Play</a></li>
<li>Android VNC Viewer：用于 Android 设备的远程连接工具     <a href="https://play.google.com/store/apps/details?id=android.androidVNC">Google Play</a></li>
<li>Ubuntu 12.04  的映像文件：用于安装 Ubuntu 的映像文件    选择下载： <a href="http://sourceforge.net/projects/linuxonandroid/files/Ubuntu/12.04/full/ubuntu1204-v4-full.zip/download">Full</a>、<a href="http://sourceforge.net/projects/linuxonandroid/files/Ubuntu/12.04/small/ubuntu1204-v4-small.zip/download">Small</a>、<a href="http://sourceforge.net/projects/linuxonandroid/files/Ubuntu/12.04/core/ubuntu1204-v4-core.zip/download">Core</a></li>
<li>ubuntu.sh ：Ubuntu 的安装脚本    <a href="http://sourceforge.net/projects/linuxonandroid/files/Ubuntu/ubuntuV6-1-script.zip">点这里下载</a>(已失效，或用迅雷)    新地址-> <a href="http://pan.baidu.com/share/link?shareid=83492&amp;uk=2416019402" title="脚本下载">下载</a></li>
<li>bootscript.sh：Ubuntu 的启动脚本     <a href="http://sourceforge.net/projects/linuxonandroid/files/bootscript.sh/download">点这里下载</a></li>
<li>Linux Installer：Linux 安装向导(这个支持个帮助向导，可以不需要)     <a href="http://sourceforge.net/projects/linuxonandroid/files/App/Complete">点这里下载</a></li>
</ul>


<h2>四.开始安装</h2>

<p>首先您的手机需要 <a href="http://zh.wikipedia.org/wiki/Chroot">chroot</a>，也就是能够获得root权限去操作，相当于越狱。不懂的可以去 Google 一下“<a href="https://www.google.com/search?hl=zh-CN&amp;newwindow=1&amp;client=ubuntu&amp;hs=YgZ&amp;channel=fs&amp;q=Android%E8%8E%B7%E5%8F%96root%E6%9D%83%E9%99%90&amp;oq=Android%E8%8E%B7%E5%8F%96root%E6%9D%83%E9%99%90&amp;gs_l=serp.12..0.22005.22005.0.22938.1.1.0.0.0.0.210.210.2-1.1.0...0.0...1c.OT_GdyR88Do">Android获取root权限</a>”。root是前提，所以先要把这个做好，不过现在很多ROM都做的很好，比如MIUI就有很好的权限管理。</p>

<h3>1.安装文件下载</h3>

<p>首先就是下载必要的文件，上面讲到的需要的 Ubuntu 12.04 的映像文件，这个是在 sourceforge.net 上的一个叫 Linux-on-Android 的项目。我上面给的地址中有三个包可供下载：</p>

<p><img src="http://i.imgur.com/Z71id.png" title="2012-08-15 16:00:15的屏幕截图" alt="" /></p>

<p>其实下面就有英文的介绍，我就在这里简单介绍一下：</p>

<ul>
<li>full 映像包含了完整的 Ubuntu 系统，其中包括 Unity 桌面，还有很多如GIMP等常用软件，非常齐全。需要 3.5G 以上空间。</li>
<li>small 映像包含了的基本的 Ubuntu 系统，其中包括 LXDE 桌面，需要 2G 以上空间。</li>
<li>core 映像包含了基础的 Ubuntu 系统，不过这个没有GUI的，也就是没有桌面只有命令行。</li>
</ul>


<p>上面下载的就是待安装的 Ubuntu 12.04 的映像文件，然后我们安装还需要安装脚本，也就是上面说的 ubuntu.sh ，还有安装后的启动脚本 bootscript.sh 。有了这些文件后我们在手机的SD卡的根目录，新建一个文件夹取名为 ubuntu ，然后把这里我们刚才下载好的文件放到这个文件夹里面，到这里 ubuntu 文件夹里就分别有 ubuntu.img、ubuntu.sh、bootcript.sh 这三个文件了。</p>

<h3>2.安装软件</h3>

<p>先展示一下我们需要的三个软件，如图：</p>

<p><img src="http://i.imgur.com/dHA4h.png" title="Screenshot_2012-08-15-18-45-48" alt="" /></p>

<p>首先需要的是 Terminal 这个软件，也就是一个终端，通过终端我们可以用来执行很多命令和脚本。上面我给出了Google Play的地址，这个在很多地方都有的下的，还有Android VNC Viewer也可以在 Google Play 里面找到安装。</p>

<p>在这里我要说一下BusyBox，它使得你可以在 Terminal 中运行很多命令，现在很多 Android 的 Rom (我用的MIUI_v4_2.8.10也是) 的终端中很多命令都不能运行，比如 cp、mv、cut 等，但是这些都是我们脚本里面需要用到的，如果不能运行这些命令而执行脚本的话，会提示 **: not found 这样的提示。所以安装 BusyBox 可以使得这些命令都能够在终端里面执行。如果你的Rom本来够强大已经包含了BusyBox的新版本，能够运行基本的shell命令的话，那也可以不用装这个。</p>

<p>当然安装BusyBox以及后面我们在Terminal中都需要 root 权限，如果是MIUI系统的话则可以直接在 <strong>授权管理 > ROOT权限管理</strong> 里面打开该选项，然后需要root权限的时候允许就可以了。其他的系统我没用过，不过可以直接用 <strong>一键ROOT工具</strong> 来操作。</p>

<p>安装BusyBox，安装好后，打开BusyBox点击 <strong>Install</strong> 开始安装，如果弹出需要ROOT权限，点下一步允许就行，如图：</p>

<p><img src="http://i.imgur.com/SCntt.png" title="Screenshot_2012-08-15-18-49-06" alt="" /></p>

<h3>3.安装 ubuntu 12.04</h3>

<p>首先，打开 <strong>终端模拟器(Terminal)</strong> ，在光标处输入 “<strong>cd /sdcard/ubuntu</strong>”(不包括引号，注意cd后有空格)然后回车，这样就来到了刚才我们在SD卡里面新建的目录了，如图：</p>

<p><img src="http://i.imgur.com/Qlq0j.png" title="Screenshot_2012-08-16-00-18-55" alt="" /></p>

<p>然后我们可以输入命令 “<strong>ls</strong>” 然后回车，我们就可以看到当前目录下的所有文件了，看一下里面是不是我们需要的三个文件，如图：</p>

<p> <img src="http://i.imgur.com/Q2due.png" title="Screenshot_2012-08-16-00-19-15" alt="" /></p>

<p> 接下来我们就要开始运行 ubuntu.sh 这个安装脚本了，但在这之前我们需要使用 root 用户来运行这个脚本，在终端中使用命令 “<strong>su</strong>” 来切换至 root 用户权限，如果弹出授权信息点击下一步允许就行了，或者直接用 一键ROOT 来开启终端重复上面操作，成功后如图之前的“<strong>$</strong>”变成了“<strong>#</strong>”，这就说明已经获得Root权限了，如图：</p>

<p><img src="http://i.imgur.com/STeo5.png" title="Screenshot_2012-08-16-00-19-43" alt="" /></p>

<p>然后运行安装脚本，输入命令 “<strong>sh ubuntu.sh</strong>”，进行安装，如图：</p>

<p><img src="http://i.imgur.com/9hHAD.png" title="Screenshot_2012-08-16-00-41-42" alt="" /></p>

<p>然后脚本为你建立了一个名字为“<strong>ubuntu</strong>”的帐号，这里提示你需要为你的帐号设置一个密码，这个密码会在以后你操作 Ubuntu 的时候一些授权应用到，比如我在这里设置密码为：“<strong>ubuntu</strong>”，这里<strong>注意</strong>的是在终端里面输入密码是不会显示出来的，你看见光标没有动静，但实际上你已经输入进去了。回车后提示再次输入密码以保证你两次密码一样，如图：</p>

<p><img src="http://i.imgur.com/KAwLW.png" title="Screenshot_2012-08-16-00-42-01" alt="" /></p>

<p>密码设置完成后，提示是否启动<a href="http://zh.wikipedia.org/wiki/VNC">VNC</a>服务和<a href="http://zh.wikipedia.org/wiki/SSH">SSH</a>服务，我们只要输入“<strong>y</strong>”然后回车，开启了这两个服务后我们才能通过远程连接来连上系统，如图：</p>

<p><img src="http://i.imgur.com/zb3If.png" title="Screenshot_2012-08-16-00-45-39" alt="" /></p>

<p>然后提示我们输入设备屏幕的尺寸，我的屏幕是854×480的，所以我输入“<strong>852×480</strong>”（<strong>小米手机注意</strong>：小米手机是854×480的，但是后面用Android VNC 连接的时候有问题，在右边会显示一条线，所以<strong>小米手机用户最好设置成“852×480”</strong>，其他手机没有测试过，在设置的时候请注意！）。<strong>注意：</strong>这里两个数字之间的<strong>不是乘号</strong>，而是<strong>字母“xyz”的“x”</strong>，输错了不能远程连接的，如图：</p>

<p><img src="http://i.imgur.com/tNQsv.png" title="Screenshot_2012-08-16-00-46-10" alt="" /></p>

<p>如图的提示已经启动了一个新的桌面，提示是否保存你刚才的设置为默认设置，只要输入“<strong>y</strong>”即可，如图：</p>

<p><img src="http://i.imgur.com/j6jFo.png" title="Screenshot_2012-08-16-00-46-46" alt="" /></p>

<p>然后你就可以看到操作完成后光标前的字符变成了“<strong>root@localhost:~</strong>#<strong><strong>”，有没有发现。其实到这里你已经进入了 Ubuntu 12.04 系统，已经完成安装配置并启动了 Ubuntu 12.04 系统，不信？你可以输入命令 “</strong>cat /etc/issue.net</strong>” 然后回车查看当前系统是不是Ubuntu 12.04，如图：</p>

<p><img src="http://i.imgur.com/1421g.png" title="Screenshot_2012-08-16-00-46-54" alt="" /></p>

<p><img src="http://i.imgur.com/B5lNa.png" title="Screenshot_2012-08-16-00-48-30" alt="" /></p>

<h3>4.远程桌面连接</h3>

<p>当然，光用命令行当然体验不到什么，我们这时候确实是已经启动了 Ubuntu12.04 ，现在只需要用远程连接工具来连接登录桌面就能看到完整的桌面系统了。这时候我们就要用到前面安装的 <strong>Android VNC Viewer</strong> 了。按手机的<strong> Home </strong>键回到手机桌面，保持<strong>终端</strong>还在后台运行。找到 <strong>Android VNC</strong> 并且打开，然后进行一些简单的配置。<strong>Nickname</strong>，为你的连接去一个名字如“<strong>ubuntu</strong>”。<strong>Password</strong> 为 “<strong>ubuntu</strong>” 。<strong>Address</strong>是ip地址，这里我们是在同一台手机上连，所以我们填写“<strong>localhost</strong>”，当然你想在别的设备上连接当前的设备那就要填写启动时提示的地址。<strong>Port</strong> 是段口号，默认<strong> 5900</strong>。还有这里比较重要的是 <strong>Color Format</strong>，这个是连接的色彩设置，建议设置成“<strong>24-bit color (4 bpp)</strong>”，要不然画质太低的话画面就惨不忍睹了。如图：</p>

<p><img src="http://i.imgur.com/foYau.png" title="Screenshot_2012-08-16-01-38-07" alt="" /></p>

<p><img src="http://i.imgur.com/avTxQ.png" title="Screenshot_2012-08-16-01-38-17" alt="" /></p>

<p>全部设置好以后，点击 <strong>Connect</strong> 就可以连接上我们本地已经在运行的 Ubuntu 12.04 系统了，如图：</p>

<p><img src="http://i.imgur.com/1O2xX.png" title="Screenshot_2012-08-16-00-50-44" alt="" /></p>

<p>使用 <strong>LibreOffice Writer</strong> ，并且支持使用<strong>手机端输入法</strong>：</p>

<p><img src="http://i.imgur.com/7PY2e.png" title="Screenshot_2012-08-16-02-13-20" alt="" /></p>

<p>使用 <strong>LibreOffice Calc</strong>：</p>

<p><img src="http://i.imgur.com/Y2kgH.png" title="Screenshot_2012-08-16-01-36-07" alt="" /></p>

<p>使用 <strong>FireFox</strong> 打开 <strong>Google</strong>：</p>

<p><img src="http://i.imgur.com/KwsUC.png" title="Screenshot_2012-08-15-12-05-53" alt="" /></p>

<p>如果想要退出桌面连接，只需要点击手机的 <strong>菜单</strong> 键，然后选择 <strong>disconnect</strong> 就可以断开连接。</p>

<h3>5.退出 Ubuntu 12.04 系统</h3>

<p>退出 Ubuntu 系统，只需要回到刚才我们运行的终端，输入命令 “<strong>exit</strong>” 回车，等待片刻即可退出 Ubuntu 系统，再次输入 “<strong>exit</strong>” 回车 则是退出手机终端的 root 用户权限，然后再次 “<strong>exit</strong>” 回车后则是退出手机终端，这样就完全退出了，如图：</p>

<p><img src="http://i.imgur.com/9TRbM.png" title="Screenshot_2012-08-16-01-39-13" alt="" /></p>

<h3>6.下次启动</h3>

<p>下次启动的时候只需要开启<strong> 终端</strong>，然后输入 “<strong>su</strong>” 获得 root 权限，再输入 “<strong>cd /sdcard/ubuntu</strong>” 来到ubuntu文件夹下，然后在输入 “<strong>sh bootscript.sh</strong>” 运行启动脚本就可以运行启动 Ubuntu 了，需要连接桌面的话按照上面说的用<strong> Android VNC</strong> 就可以了。</p>

<h2>四.电脑端连接使用手机上的 Ubuntu 12.04</h2>

<p>到这里你一定成功在手机上跑起 Ubuntu 12.04 了吧，感觉不一样吧！还没完呢！在这里因为我们在手机上的 Ubuntu 12.04 开启了 VNC 和 SSH 服务，当然在手机连上网（最好是WIFI或局域网）了以后，我们也可以用电脑去远程连接登录到手机上的 Ubuntu 12.04 ，这样的话，我们就可以通过电脑来操作手机上的 Ubuntu 了。</p>

<p>VNC服务是与操作系统无关的，所以不管你电脑是什么系统都可以通过VNC来连接登录到手机上的 Ubuntu。在 Windows 操作系统上可以通过 <strong>VNC 客户端</strong> 来连接。因为我电脑的系统是Linux 所以我在这里只演示 Linux 下连接登录到手机的 Ubuntu。Windows的也大同小异，所以Google一下吧。</p>

<p>在Linux下，使用 <strong>Remmina 远程桌面客户端</strong> 这款工具就可以连接到按照我们上面的方法启动了 Ubuntu 的手机，其中<strong>服务器地址</strong> 就是你在手机上启动 Ubuntu 的时候，提示的 VNC 地址 。配置如图：</p>

<p><img src="http://i.imgur.com/7qtaz.png" title="2012-08-16 02:41:46的屏幕截图" alt="" /></p>

<p>点击连接，就可以连接登录到手机上的 Ubuntu 12.04 了，这样你就可以在电脑上操作手机上的 ubuntu 系统了，如图：</p>

<p><img src="http://i.imgur.com/GIUac.png" title="2012-08-16 02:47:29的屏幕截图" alt="" /></p>

<h2>五.总结</h2>

<p>Android 智能手机 装上了原生的 Ubuntu 12.04 ，这需要感谢 Zachary Powell 团队在 SourceForge 上提供的文件及脚本，不仅是 Ubuntu ，你也可以在 Android 手机上安装 Fedora、openSUSE、Debian、ArchLinux 等系统，这些系统的影响文件及脚本 Zachary Powell 团队在 SourceForge 上都有提供，感兴趣的朋友可以尝试一下！</p>

<p>说到底装上的还是原生的 Ubuntu ，但是还是挺期待 Canonical 专门为 Android 设备定制的 Ubuntu 系统，现在 Canonical 公司也已经在为 Android 设备打造专属的 Ubuntu 系统了，期待它能早日面世。相关信息可以查阅：http://www.ubuntu.com/devices/android</p>

<p><strong>作者：<a href="http://www.dawndiy.com">DawnDIY</a><br/>
本文地址：</strong><br/>
<strong>本文原创，如果转载请注明原文出处及原文地址，3Q</strong></p>

<p> </p>

		
		
	</div>

<div class="meta">
	
		<span class="comments"><a href="/archives/229/blog/page/2/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/archives/186">
		
			PyGtk学习笔记(5)–布局管理(Table)</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: 








  


<time datetime="2012-07-31T00:00:00+08:00" pubdate data-updated="true">Jul 31<span>st</span>, 2012</time></div>
      <div class="tags">Tags: 


	<a class='category' href='/blog/categories/pygtk/'>PyGtk</a>, <a class='category' href='/blog/categories/python/'>Python</a>


</div>
    </div>
		<h1></h1>

<p>这次学习一下一个简单的布局管理–Table。Table我说他简单是因为是一个“方方正正”的容器，和HTML中的标签类似，它使用于一些平面需要行和列排列的UI中。</p>

<h2>1.介绍</h2>

<p>Table可以用来很好的管理行和列对齐和布局的UI中，比如《计算器》、《五子棋》、《扫雷》等，这些程序的主界面都是许许多多的子部件方方正正的行列对齐地排列在一起的。说道这几个程序，你应该对Table有一定的猜想了吧。下面开始介绍。</p>

<h3>Table类的概要：</h3>

<pre><code>class gtk.Table(gtk.Container):
    gtk.Table(rows=1, columns=1, homogeneous=False)

    def resize(rows, columns)

    def attach(child, left_attach, right_attach, top_attach, bottom_attach, xoptions=gtk.EXPAND|gtk.FILL, yoptions=gtk.EXPAND|gtk.FILL, xpadding=0, ypadding=0)

    def set_row_spacing(row, spacing)

    def get_row_spacing(row)

    def set_col_spacing(column, spacing)

    def get_col_spacing(column)

    def set_row_spacings(spacing)

    def get_default_row_spacing()

    def set_col_spacings(spacing)

    def get_default_col_spacing()

    def set_homogeneous(homogeneous)

    def get_homogeneous()
</code></pre>

<h3></h3>

<h3>Table的继承关系：</h3>

<pre><code>-- gobject.GObject
   -- gtk.Object
     -- gtk.Widget
       -- gtk.Container
         -- gtk.Table
</code></pre>

<h3> 构造方法：</h3>

<pre><code>gtk.Table(rows=1, columns=1, homogeneous=False)
</code></pre>

<p>参数：</p>

<p><strong><code>rows</code></strong> :</p>

<p>行数</p>

<p><strong><code>columns</code></strong> :</p>

<p>列数</p>

<p><strong><code>homogeneous</code></strong> :</p>

<p>如果为True，所有的单元格都与最大的单元格尺寸相同</p>

<p><em>Returns</em> :</p>

<p><code>一个新的 gtk.Table 对象</code></p>

<p>如果 rows 和 columns 没有赋值，默认为 1 。</p>

<p><strong>注意：</strong><br/>
这里的rows和columns意思是行数和列数，但在布局的时候我们如果把它们理解成分割线的话这样更好理解。因为下面attach这个方法中的一些参数是通过起始和结束来确定一个子控件的位置的，所以我们把行列抽象理解成分割线的话更容易理解构建。比如 rows =2 , columns = 2 , 那么它的布局应该是这样的：</p>

<p>0               1                 2<br/>
0 ———- ———- <br/>
|                  |                 |<br/>
1 ———- ———- <br/>
|                  |                 |<br/>
2 ———- ———-</p>

<h3>主要方法：</h3>

<p><strong>gtk.Table.attach</strong></p>

<pre><code>def attach(child, left_attach, right_attach, top_attach, bottom_attach, xoptions=gtk.EXPAND|gtk.FILL, yoptions=gtk.EXPAND|gtk.FILL, xpadding=0, ypadding=0)
</code></pre>

<p><strong><code>child</code></strong> :</p>

<p>需要添加的控件</p>

<p><strong><code>left_attach</code></strong> :</p>

<p>子控件左部起始列号。（<strong>可以用上面的分割线来理解</strong>）</p>

<p><strong><code>right_attach</code></strong> :</p>

<p>子控件右部结束列号。</p>

<p><strong><code>top_attach</code></strong> :</p>

<p>子控件顶部起始列号。</p>

<p><strong><code>bottom_attach</code></strong> :</p>

<p>子控件底部结束列号。</p>

<p><strong><code>xoptions</code></strong> :</p>

<p>当 table 水平调整大小时，用于指定子控件的属性。默认值 <code>gtk.FILL</code>|<code>gtk.EXPAND</code></p>

<p><strong><code>yoptions</code></strong> :</p>

<p>当 table 垂直调整大小时，用于指定子控件的属性。默认值 <code>gtk.FILL</code>|<code>gtk.EXPAND</code></p>

<p><strong><code>xpadding</code></strong> :</p>

<p>添加控件的左侧和右侧的填充量，默认值 0</p>

<p><strong><code>ypadding</code></strong> :</p>

<p>添加控件的上侧和下侧的填充量，默认值 0</p>

<p><em><code>xoptions</code></em> 和 <em><code>yoptions</code></em> 确定控件在水平和垂直方向上的扩展属性，默认值是：<code>gtk.FILL</code>|<code>gtk.EXPAND</code></p>

<p>  <code>gtk.EXPAND</code></p>

<p>table单元格将扩展占据分配的所有空闲空间。</p>

<p><code>gtk.SHRINK</code></p>

<p>控件随着table单元格收缩而收缩。</p>

<p><code>gtk.FILL</code></p>

<p>空间将会填充所有table单元格分配的空间。</p>

<h2>2.示例</h2>

<p>上面都是不实在的东西，下面来看一个例子，有图有真相，先上图：</p>

<p>[![][2]][2]</p>

<p>如图所示，你应该想到Table是怎么一个布局容器吧。接下来看一下完整代码：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*

# Table layout container
# PyGtk Study Notes By DawnDIY
# http://www.dawndiy.com

import pygtk
pygtk.require('2.0')
import gtk

class TableLC:
    def __init__(self):
        self.win = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.win.set_title("Table Layout Container")
        self.win.set_size_request(300,250)
        self.win.set_position(gtk.WIN_POS_CENTER)

        table = gtk.Table(4, 3, True)   # 4行3列
        table.attach(gtk.Button("1"), 0, 1, 0, 1)
        table.attach(gtk.Button("2"), 1, 2, 0, 1)
        table.attach(gtk.Button("3"), 2, 3, 0, 1)
        table.attach(gtk.Button("4"), 0, 1, 1, 2)
        table.attach(gtk.Button("5"), 1, 2, 1, 2)
        table.attach(gtk.Button("6"), 2, 3, 1, 2)
        table.attach(gtk.Button("7"), 0, 1, 2, 3)
        table.attach(gtk.Button("8"), 1, 2, 2, 3)
        table.attach(gtk.Button("9"), 2, 3, 2, 3)
        table.attach(gtk.Button("0"), 1, 2, 3, 4)

        self.win.add(table)
        self.win.connect("destroy", gtk.main_quit)
        self.win.show_all()

if __name__ == "__main__":
    tab = TableLC()
    gtk.main()
</code></pre>

<p>在这个例子中，我们主要看的还是Table中子控件的布局方式，结合前面介绍的 table.attach 方法，我们首先通过 gtk.Table(4, 3, True)来建立了一个 4行 3列 的 table 。<br/>
那么这些数字是怎么布局的呢？<br/>
就添加数字“1”来说明，table.attach(gtk.Button(“1″), 0, 1, 0, 1) ，首先第一个参数就不说了；第二个参数 “0”表示控件从第0列起始；第三个参数“1”表示控件结束于第2列前；第四个参数“0”表示控件开始于第0行；第五个参数表示控件结束于第1行前。这样就确定了数字“1”的位置以及所占行列了。<br/>
其他的也就都是一样的。</p>

<p>那么我们多举些例子，改一下代码看看有什么效果。</p>

<p>如果把数字“0”的布局改成：</p>

<pre><code>table.attach(gtk.Button("0"), 1, 3, 3, 4)
</code></pre>

<p>效果如下：</p>

<p>[![][3]][3]</p>

<p>因为我将第二个参数和第三个参数改成了 1 , 3 。也就是说数字“0”是从第1列起始结束于第3列前。这样它就占据了2列的位置了。</p>

<p>table.attach 还有四个参数没有讲到，下面我们继续修改一下代码。</p>

<p>我们先说一下我们接下来要修改的目的：<br/>
1.数字“1”上下分别设置边距为5，左右边距分别为10。<br/>
2.数字“2”垂直方向设置为FILL，水平方向设置为EXPAND。<br/>
3.数字“3”水平垂直方向均设置为<code>SHRINK</code>。</p>

<p>那么我们修改的局部代码为：</p>

<pre><code>table.attach(gtk.Button("1"), 0, 1, 0, 1, gtk.EXPAND|gtk.FILL, gtk.EXPAND|gtk.FILL, 10, 5)
        table.attach(gtk.Button("2"), 1, 2, 0, 1, gtk.EXPAND, gtk.FILL)
        table.attach(gtk.Button("3"), 2, 3, 0, 1, gtk.SHRINK, gtk.SHRINK)
</code></pre>

<p>效果：</p>

<p>[![][4]][4]</p>

<p>就是这样的。table.attach 后面几个参数，对于动态调整窗口时，控件的布局非常有用。认真参考上面我给出的 table.attach 的介绍，是能够理解的。</p>

<p>OK，今天学到这里，使用这些布局已经能够构建很多UI了，下次学学别的，未完，待续…………..</p>

<p> </p>

<p> </p>

<p> </p>

		
		
	</div>

<div class="meta">
	
		<span class="comments"><a href="/archives/186/blog/page/2/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/archives/155">
		
			Linux 下安装配置 JDK7</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: 








  


<time datetime="2012-07-31T00:00:00+08:00" pubdate data-updated="true">Jul 31<span>st</span>, 2012</time></div>
      <div class="tags">Tags: 


	<a class='category' href='/blog/categories/java/'>Java</a>, <a class='category' href='/blog/categories/linux/'>Linux</a>


</div>
    </div>
		<h1></h1>

<p>自从从Oracle收购Sun近三年来，已经有很多变化。早在8月，甲骨文将“Operating System Distributor License for Java”许可证终结，这意味着第三方将不可以依据这一许可分发他们的软件包。<br/>
<strong>　　</strong>因此Ubuntu Linux已经开始禁用所有机器上的Oracle JDK浏览器插件，并很快会从档案中删除软件包。<br/>
公司指出，禁用Oracle的插件将可以帮助提高安全性，因为这些插件已经被证实包含许多漏洞，虽然这是一个事实，但真正的原因恐怕是Sun的 JDK在升级时会清理掉用户机器上自认为不安全的软件，大多数PC用户认为这样很安全，但通常基于UNIX系统的用户并不这么认为。<br/>
Oracle的JDK被废弃后，OpenJDK将取代它的位置在Ubuntu及其它Linux中默认安装。</p>

<p>虽然很多Linux发行版现在已经自带OpenJDK，但是在开发过程中与Oracle-JDK(SUN-JDK)还是略有不同。通常，Java开发人员还是以Oracle-JDK为标准来进行开发。<br/>
下面介绍一下Linux下的JDK安装与配置，这里使用的Linux发行版是Ubuntu 12.04。</p>

<h2>1.下载JDK</h2>

<p>目前最新的JDK版本是：Java SE Development Kit 7u5</p>

<p>下载地址：</p>

<p>查看最新：</p>

<h2>2.解压安装</h2>

<p>我们把JDK安装到这个路径：/usr/lib/jvm<br/>
如果没有这个目录（第一次当然没有），我们就新建一个目录</p>

<pre><code>cd /usr/lib
sudo mkdir jvm
</code></pre>

<p>建立好了以后，我们来到刚才下载好的压缩包的目录，解压到我们刚才新建的文件夹里面去，并且修改好名字方便我们管理</p>

<pre><code>sudo tar zxvf ./jdk-7-linux-i586.tar.gz  -C /usr/lib/jvm
cd /usr/lib/jvm
sudo mv jdk1.7.0_05/ jdk7
</code></pre>

<h2> 3.配置环境变量</h2>

<pre><code>gedit ~/.bashrc
</code></pre>

<p>在打开的文件的末尾添加</p>

<pre><code>export JAVA_HOME=/usr/lib/jvm/jdk7
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
</code></pre>

<p>保存退出，然后输入下面的命令来使之生效</p>

<pre><code>source ~/.bashrc
</code></pre>

<h2> 4.配置默认JDK</h2>

<p>由于一些Linux的发行版中已经存在默认的JDK，如OpenJDK等。所以为了使得我们刚才安装好的JDK版本能成为默认的JDK版本，我们还要进行下面的配置。<br/>
执行下面的命令：</p>

<pre><code>sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk7/bin/java 300
sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk7/bin/javac 300
</code></pre>

<p> 注意：如果以上两个命令出现找不到路径问题，只要重启一下计算机在重复上面两行代码就OK了。</p>

<p>执行下面的代码可以看到当前各种JDK版本和配置：</p>

<pre><code>sudo update-alternatives --config java
</code></pre>

<h2> 5.测试</h2>

<p>打开一个终端，输入下面命令：</p>

<pre><code>java -version
</code></pre>

<p>显示结果：</p>

<pre><code>java version "1.7.0_05"
Java(TM) SE Runtime Environment (build 1.7.0_05-b05)
Java HotSpot(TM) Server VM (build 23.1-b03, mixed mode)
</code></pre>

<p>这表示java命令已经可以运行了。</p>

<p> </p>

<p> </p>

		
		
	</div>

<div class="meta">
	
		<span class="comments"><a href="/archives/155/blog/page/2/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/archives/153">
		
			Ubuntu 下搭建 Android 开发环境(图文)</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: 








  


<time datetime="2012-07-31T00:00:00+08:00" pubdate data-updated="true">Jul 31<span>st</span>, 2012</time></div>
      <div class="tags">Tags: 


	<a class='category' href='/blog/categories/android/'>Android</a>


</div>
    </div>
		<h1></h1>

<p>随着智能手机、平板电脑等越来越普及，现在的移动平台开发越来越火，IOS、Android等等，以前一直没有开发过移动平台的应用，然而网上的N多教程全是Windows平台的，而我却坚持这Linux桌面，那么这么新鲜、这么火、这么有前景的开发，我也先起个头，把环境搭建起来先。</p>

<h2>1.安装JDK</h2>

<p>请看这里 > <a href="http://www.dawndiy.com/archives/155" title="Linux 下安装配置 JDK7">《Linux 下安装配置 JDK7》</a></p>

<h2>2.安装Eclipse</h2>

<p>现在Eclipse已经出4.2版本，并且官方也已经将4.x版作为默认的下载版本了，大家可以自己选择，下面给出4.x和3.7.x的下载链接：</p>

<p><strong>Eclipse Juno (4.2)：</strong><br/>
Windows    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops4/R-4.2-201206081400/eclipse-SDK-4.2-win32.zip">32-bit</a>    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops4/R-4.2-201206081400/eclipse-SDK-4.2-win32-x86_64.zip">64-bit</a><br/>
Mac    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops4/R-4.2-201206081400/eclipse-SDK-4.2-macosx-cocoa.tar.gz">32-bit</a>    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops4/R-4.2-201206081400/eclipse-SDK-4.2-macosx-cocoa-x86_64.tar.gz">64-bit</a><br/>
Linux    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops4/R-4.2-201206081400/eclipse-SDK-4.2-linux-gtk.tar.gz">32-bit</a>    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops4/R-4.2-201206081400/eclipse-SDK-4.2-linux-gtk-x86_64.tar.gz">64-bit</a><strong><br/>
</strong></p>

<p><strong>Eclipse Indigo (3.7)：</strong><br/>
Windows    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops/R-3.7.2-201202080800/eclipse-SDK-3.7.2-win32.zip">32-bit</a>    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops/R-3.7.2-201202080800/eclipse-SDK-3.7.2-win32-x86_64.zip">64-bit</a><br/>
Mac    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops/R-3.7.2-201202080800/eclipse-SDK-3.7.2-macosx-cocoa.tar.gz">32-bit</a>    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops/R-3.7.2-201202080800/eclipse-SDK-3.7.2-macosx-cocoa-x86_64.tar.gz">64-bit</a><br/>
Linux    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops/R-3.7.2-201202080800/eclipse-SDK-3.7.2-linux-gtk.tar.gz">32-bit</a>    <a href="http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops/R-3.7.2-201202080800/eclipse-SDK-3.7.2-linux-gtk-x86_64.tar.gz">64-bit</a></p>

<p>下载后解压到本地直接都可以使用了（在配置好JDK的前提下）。</p>

<h2>3.下载安装 Android SDK</h2>

<p>先下载好最新的 Android SDK Package。这里我给出下载地址：</p>

<p>Platform</p>

<p>Package</p>

<p>Size</p>

<p>MD5 Checksum</p>

<p>Windows</p>

<p><a href="http://dl.google.com/android/android-sdk_r20.0.1-windows.zip">android-sdk_r20.0.1-windows.zip</a></p>

<p>90370975 bytes</p>

<p>5774f536892036f87d3bf6502862cea5</p>

<p><a href="http://dl.google.com/android/installer_r20.0.1-windows.exe">installer_r20.0.1-windows.exe</a> (Recommended)</p>

<p>70486979 bytes</p>

<p>a8df28a29c7b8598e4c50f363692256d</p>

<p>Mac OS X (intel)</p>

<p><a href="http://dl.google.com/android/android-sdk_r20.0.1-macosx.zip">android-sdk_r20.0.1-macosx.zip</a></p>

<p>58217336 bytes</p>

<p>cc132d04bc551b23b0c507cf5943df57</p>

<p>Linux (i386)</p>

<p><a href="http://dl.google.com/android/android-sdk_r20.0.1-linux.tgz">android-sdk_r20.0.1-linux.tgz</a></p>

<p>82607616 bytes</p>

<p>cd7176831087f53e46123dd91551be32</p>

<p>官网下载地址：</p>

<p>下载好后当然是解压了，解压到您的工作目录，这个目录就是今后使用SDK的目录：</p>

<pre><code>tar zvxf android-sdk_r20.0.1-linux.tgz
</code></pre>

<p>解压找到 tools 目录下的 android 后如图：</p>

<p><img src="http://i.imgur.com/qtV6C.png" title="2012-07-31 10:08:30的屏幕截图" alt="" /></p>

<p> </p>

<p>这个就是 Android SDK Manager，你可以通过这个来配置、管理和下载最新的SDK。</p>

<p>首先我们先通过 Android SDK Manager 来添加平台和包，打开 Android SDK Manager 后勾选你需要的工具和包，这里 Android SDK Manager 会默认为您勾选它所推荐的包，您只需要点击下载安装就可以了。如图：</p>

<p><img src="http://i.imgur.com/kZRDG.png" title="2012-07-31 10:11:13的屏幕截图" alt="" /></p>

<h2>4.配置 Android SDK 开发调试环境</h2>

<p>在这里我们是要配置开发调试环境，以便我们在控制台能够很好的使用 SDK 。如果你只是希望使用 Eclipse 来做 Android 开发的话，这里也可以省略。不过我还是觉得控制台挺好的，虽然一片片的看着头晕，呵呵。</p>

<p>首先配置环境变量，和配置 JDK 一样。运行一下代码来配置环境变量：</p>

<pre><code>gedit ~/.bashrc
</code></pre>

<p>在文件的最末端添加下面内容：</p>

<pre><code># Android SDK
export ANDROID_SDK=/home/dawndiy/workspace/android/android-sdk-linux
export PATH=$ANDROID_SDK/platform-tools:$ANDROID_SDK/tools:$PATH
</code></pre>

<p>当然， “ANDROID_SDK=” 后面的内容当然是你自己的 SDK 所在的目录啦，千万别照搬啊，上面的可是我电脑上的。修改好了以后记得保存，最后运行一下：</p>

<pre><code>source ~/.bashrc
</code></pre>

<p> </p>

<p>————更新————-</p>

<p>==这里是后来添加上的==</p>

<p>在之后的使用中我发现在控制台使用  adb 命令正常，但是有的时候需要 root 权限的时候我们再使用 sudo adb 的时候居然会提示 找不到 adb 命令。后来我找到了解决方法，这里说明一下：</p>

<pre><code>cd /usr/bin
rm -rf adb
sudo ln -s /home/dawndiy/workspace/android/android-sdk-linux/platform-tools/adb
</code></pre>

<p>这样就可以解决在 sudo 下也可以使用 adb 了，如果 fastboot 也有这样的情况，一样解决！</p>

<p>—————————–</p>

<p> </p>

<h2>5.安装 ADT(Android Development Tools) 插件</h2>

<p>打开 Eclipse，选择 <strong>Help</strong> > <strong>Install New Software…</strong>.</p>

<p>点击 <strong>Add</strong>，在 <strong>Name</strong> 输入 “ADT Plugin” 作为名字，在 <strong>Location</strong> 输入 “https://dl-ssl.google.com/android/eclipse/”(不要引号)，如图：</p>

<p><img src="http://i.imgur.com/jPRY9.png" title="2012-07-31 12:50:46的屏幕截图" alt="" /></p>

<p>添加好插件地址后，在 <strong>Work with</strong> 中选择刚才添加的插件地址，然后等待一会儿下面就会出现需要安装的插件。选择需要安装的插件后点击安装即可。如图：</p>

<p><img src="http://i.imgur.com/7Moeo.png" title="2012-07-31 12:57:59的屏幕截图" alt="" /></p>

<p>接下来就是等待下载安装，安装后了以后重启Eclipse即安装完成。</p>

<h2>6.配置 ADT 插件</h2>

<p>这里可能重启Eclipse后就会弹出ADT的配置对话框，如果没有弹出的话下面会介绍。</p>

<p>弹出的对话框如图，只需要把前面安装好的 Android SDK 的目录填入 <strong>Location</strong> 中就可以了。</p>

<p><img src="http://i.imgur.com/tssKQ.png" title="2012-07-31 13:15:48的屏幕截图" alt="" /></p>

<p>然后弹出一个问你是否愿意想Google反馈使用信息的对话框，Yes or No 随便，然后 Finish。</p>

<p><strong>如果没有弹出ADT配置对话框，那么我们如下操作来配置。</strong></p>

<p>打开 Eclipse ，选择 <strong>Window</strong> > <strong>Preferences…</strong> 来打开选项面板。</p>

<p>在左侧选择 <strong>Android</strong> ，在右侧面板中找到 <strong>SDK Location</strong> 点击 <strong>Browse…</strong> 来选择你前面安装的SDK目录，最后点击 <strong>Apply</strong> 即可。如图：</p>

<p><img src="http://i.imgur.com/9zpfS.png" title="2012-07-31 13:27:51的屏幕截图" alt="" /></p>

<p>这样您的ADT就基本配置完成了。最后为了保证您的插件是最新的，可以选择 <strong>Help</strong> > <strong>Check for Updates</strong> 让Eclipse自动检测需要更新的组件来更新。</p>

<h2>7.新建 AVD(android vitural device)</h2>

<p>开发的时候当然需要一台设备来做测试，Android SDK 的工具中提供了 Android 虚拟设备的功能，能够在本地虚拟一台 Android 设备。在正式开发之前，我们需要配置新建一个 AVD ，当然你可以使用前面安装好的 Android SDK Manager 来新建，这里我们也可以直接在已经配置好了的Eclipse里面进行添加。</p>

<p>选择 <strong>Windows > AVD Manager</strong> 点击 <strong>New</strong> 来新建一台 AVD ，然后在里面配备相应的参数，如图：</p>

<p><img src="http://i.imgur.com/3ypIG.png" title="2012-07-31 13:46:19的屏幕截图" alt="" /></p>

<p>点击 <strong>Create AVD</strong> 完成。</p>

<p>你可以在新建完成后在 AVD Manager 里面运行您刚才新建的虚拟设备，附上几幅图：</p>

<p><img src="http://i.imgur.com/xpi9z.png" title="2012-07-31 14:07:46的屏幕截图" alt="" /></p>

<p><img src="http://i.imgur.com/Hp9T3.png" title="2012-07-31 14:11:01的屏幕截图" alt="" /></p>

<h2>8.新建 Android 项目</h2>

<p>打开 Eclipse ， <strong>File > New > Other…</strong> 选择 Android Application Project 后，就会出现向导对话框，然后更具向导填好相关信息，最后就可以生成一个 Android 项目，如图：</p>

<p><img src="http://i.imgur.com/ndSpv.png" title="2012-07-31 16:20:49的屏幕截图" alt="" /></p>

<p>填写应用名、项目名、包名等信息，还有选择构建的SDK版本。</p>

<p><img src="http://i.imgur.com/wZGpZ.png" title="2012-07-31 14:21:57的屏幕截图" alt="" /></p>

<p>设置应用的图标：</p>

<p><img src="http://i.imgur.com/HjUCR.png" title="2012-07-31 14:23:03的屏幕截图" alt="" /></p>

<p><img src="http://i.imgur.com/2CK0b.png" title="2012-07-31 14:25:32的屏幕截图" alt="" /></p>

<p>完成新建 Android 项目：</p>

<p><img src="http://i.imgur.com/ISKJf.png" title="2012-07-31 16:14:08的屏幕截图" alt="" /></p>

<p>项目建立好后，默认给出的是一个示例，我们直接运行一下看能否运行，点击工具栏的绿色运行按钮或者键盘 Ctrl F11 。运行效果如下：</p>

<p><img src="http://i.imgur.com/fl8sA.png" title="2012-07-31 16:13:23的屏幕截图" alt="" /></p>

<p>这样，我们的环境就配置完成了！</p>

<h2>9.总结</h2>

<p>一直都想去尝试开发一款自己的Android程序，但是一直都没有去学，趁今天下午有时间，参考了官方的文档，自己摸索的搭建了一下开发环境，算一个开头。接下来就慢慢的学习吧～ Over………………….</p>

		
		
	</div>

<div class="meta">
	
		<span class="comments"><a href="/archives/153/blog/page/2/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/archives/127">
		
			PyGtk学习笔记(4)–布局管理(Alignment)</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: 








  


<time datetime="2012-07-29T00:00:00+08:00" pubdate data-updated="true">Jul 29<span>th</span>, 2012</time></div>
      <div class="tags">Tags: 


	<a class='category' href='/blog/categories/pygtk/'>PyGtk</a>, <a class='category' href='/blog/categories/python/'>Python</a>


</div>
    </div>
		<h1></h1>

<p>前面我们学习了HBox和VBox这对灵活的布局器，今天再来学习一个非常灵活的布局管理器——Alignment 。Alignment名为对齐布局管理，顾名思义，它是主要是用来管理部件对齐和子部件大小的。Alignment在对于需要更具Window等部件大小变化而变化的子部件对齐来说，使用非常方面。所以对于制作一款体验较好的应用程序来说，值得学习使用Alignment来管理子部件的对齐和大小。</p>

<h2>1.介绍</h2>

<p>这次先不上图了，先来讲解一下Alignment的相关功能。<br/>
使用Alignment的时候应该注意，Alignment只能为其添加一个子部件，也就是说只能add一个widget。那一个部件怎么对齐？所以，我们通常配合VBox和HBox（<a href="http://www.dawndiy.com/archives/107" title="PyGtk学习笔记(3)–布局管理(VBox, HBox)">PyGtk学习笔记(3)–布局管理(VBox, HBox)</a>）来使用。详细说，就是我们把需要的部件添加Box中后，再把Box交给Alignment来管理它的子部件的对齐和大小。这样就可以构建美观的UI了。</p>

<p>Alignment类的概要：</p>

<pre><code>class gtk.Alignment(gtk.Bin):
    gtk.Alignment(xalign=0.0, yalign=0.0, xscale=0.0, yscale=0.0)

    def set(xalign, yalign, xscale, yscale)

    def set_padding(padding_top, padding_bottom, padding_left, padding_right)

    def get_padding()
</code></pre>

<p> Alignment的继承关系：</p>

<pre><code>-- gobject.GObject
   -- gtk.Object
     -- gtk.Widget
       -- gtk.Container
         -- gtk.Bin
           -- gtk.Alignment
</code></pre>

<p>构造函数：</p>

<pre><code>gtk.Alignment(xalign=0.0, yalign=0.0, xscale=0.0, yscale=0.0)
</code></pre>

<p><strong><code>xalign</code></strong> :</p>

<p>数值表示子部件左边的空闲位置占全部水平空闲位置的百分比。数值从0.0到1.0，0表示子部件左对齐，1表示子部件右对齐。默认0.0。</p>

<p><strong><code>yalign</code></strong> :</p>

<p>数值表示子部件上边的空闲位置占全部垂直空闲位置的百分比。数值从0.0到1.0，0表示子部件顶对齐，1表示子部件底对齐。默认0.0。</p>

<p><strong><code>xscale</code></strong> :</p>

<p>数值表示子部件占全部水平位置的百分比。数值从0.0到1.0，0表示子部件最小宽度，1表示子部件最大宽度。默认0.0。</p>

<p><strong><code>yscale</code></strong> :</p>

<p>数值表示子部件占全部垂直位置的百分比。数值从0.0到1.0，0表示子部件最小高度，1表示子部件最大高度。默认0.0。</p>

<p><em>Returns</em> :</p>

<p>一个新的Alignment对象。</p>

<p>其他函数：</p>

<pre><code>set_padding(padding_top, padding_bottom, padding_left, padding_right)
</code></pre>

<p>这个函数是用来设置边距的，也就是说Alignment管理的子部件和外出部件的上、下、左、右的边距。</p>

<h2>2.实例详解</h2>

<p>看实在的，来举一个例子看一看。先上图：</p>

<p>[![][3]][3]如图所示，上面的按钮是使用了Alignment布局管理来控制其大小和对齐的。下面是完整代码：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*

# Alignment layout container
# PyGtk Study Notes By DawnDIY
# http://www.dawndiy.com

import pygtk
pygtk.require('2.0')
import gtk

class AlignLC:
    def __init__(self):
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_title("Alignment Layout Container")
        self.window.set_size_request(300,250)
        self.window.set_position(gtk.WIN_POS_CENTER)

        btn1 = gtk.Button("btn1")
        btn2 = gtk.Button("btn2")
        btn3 = gtk.Button("btn3")

        vbox = gtk.VBox(True,0)
        vbox.add(btn1)
        vbox.add(btn2)
        vbox.add(btn3)

        align = gtk.Alignment(0.5,1,0.7,0)  # 子部件左边空余50%的空闲空间（居中），子部件以最大高度占满垂直空间，子部件宽度为水平空间的70%

        align.add(vbox)
        self.window.add(align)
        self.window.connect("destroy",gtk.main_quit)
        self.window.show_all()

if __name__ == "__main__":
    al = AlignLC()
    gtk.main()
</code></pre>

<p>因为Alignment只能为其添加一个子部件的特性，所以我们配合使用了VBox。在VBox一个共有3个Button，然后把VBox添加至Alignment内。其中的关键是Alignment实例化的时候其中的参数。参照前面讲的构造函数参数的介绍和代码中我注释的内容，第一个 0.5 表示VBox中的三个Button左边的空间占全部空闲空间的50%,这样也达到了居中的效果。第二个 1 表示的是，垂直方向上三个Button顶部的空间为全部空闲空间，也就是说底部距离为0。第三个 0.7 表示三个Button的总宽度为水平宽度的70%。最后一个 0 表示三个Button的高度为其最小高度。<br/>
而且这里使用Alignment布局管理来处理的大小和对齐方案都是适应窗口变化的，即使窗口重新调整，这些布局也能按照设置来适应当前变化。</p>

<h2>3.其他示例</h2>

<p>上面一个例子可能不好理解，下面我诺列一下参数变化后不同的效果：</p>

<p>gtk.Alignment(0,0,0,0) 效果：</p>

<p>[![][4]][4]</p>

<p>gtk.Alignment(0.5,0,0,0) 效果：</p>

<p>[![][5]][5]</p>

<p>gtk.Alignment(0.5,0,0.5,0) 效果：</p>

<p>[![][6]][6]</p>

<p>gtk.Alignment(0.5,0.8,0.5,0) 效果：</p>

<p>[![][7]][7]</p>

<p>gtk.Alignment(0.5,0.8,0.5,0.5) 效果：</p>

<p>[![][8]][8]</p>

<p>gtk.Alignment(0,0,1,1) 效果：</p>

<p>[![][9]][9]</p>

<p>gtk.Alignment(0,0,1,1)<br/>
align.set_padding(50,30,10,2)<br/>
效果：</p>

<p>[![][10]][10]</p>

<p>前面没有讲到set_padding这个方法，这个方法也就设置边距，如上图就是设置顶部边距为50，底部边距为30，左边距为10，右边距为2的效果。</p>

<p>Alignment是一个灵活的布局管理器，主要用于管理其子部件的大小尺寸和对齐方案。配合使用其他的布局管理，你可以用它来构造体验有好的UI。</p>

<p>未完，待续……</p>

<p> </p>

<p> </p>

<p> </p>

		
		
	</div>

<div class="meta">
	
		<span class="comments"><a href="/archives/127/blog/page/2/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/archives/107">
		
			PyGtk学习笔记(3)–布局管理(VBox, HBox)</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: 








  


<time datetime="2012-07-15T00:00:00+08:00" pubdate data-updated="true">Jul 15<span>th</span>, 2012</time></div>
      <div class="tags">Tags: 


	<a class='category' href='/blog/categories/pygtk/'>PyGtk</a>, <a class='category' href='/blog/categories/python/'>Python</a>


</div>
    </div>
		<h1></h1>

<p>前面一次学习了一个很简单的Fixed布局方式，这次和DawnDIY来学习一下最常用的Box布局管理。Box布局管理分为VBox和HBox两种，在GTK 3中都把这两个合并为Box一个部件了，但是目前来说PyGtk还是GTK 2的，所以DawnDIY还是建议还是把VBox和HBox单独用，不用统一成Box，这样写出来的程序兼容性更好。GTK 3中的Box可以等到PyGObject比较普及、稳定的时候在用。毕竟还是那句话，用最稳定的，不用最新的。</p>

<h2>1.介绍</h2>

<p>下面我们先介绍一下VBox和HBox。</p>

<p>VBox是一个垂直布局容器。这个容器里的部件都是以垂直排列的方式一个个竖直分布在容器中。<br/>
HBox是一个水平布局容器。这个容器里的部件都是以水平排列的方式一个个横向分布在容器中。<br/>
这两个布局容器是最常用的两个布局容器，我们可以配合使用他们来构建出你想要的UI。</p>

<h2>2.VBox</h2>

<p>先来看一个VBox的示例，上图先：</p>

<p>[![][2]][2]</p>

<p>从上面的图中可以看到，有两个按钮，一个大一个小，而且是竖直排列的。small和big按钮都是放在VBox中，然后在把VBox添加到主窗口中就行了，这个示例很简单，下面是完整代码：</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*

# VBox layout container
# PyGtk Study Notes By DawnDIY
# http://www.dawndiy.com

import pygtk
pygtk.require('2.0')
import gtk

class VBoxLC:
    def __init__(self):
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_title("VBox Layout Container")
        self.window.set_size_request(300,250)
        self.window.set_position(gtk.WIN_POS_CENTER)

        self.window.connect("destroy", gtk.main_quit)

        vbox = gtk.VBox(False, 5)    # 建立 VBox 布局容器，空间不均等分配，子部件间隔 5 像素
        btn1 = gtk.Button("small")
        btn2 = gtk.Button("Big")
        btn2.set_size_request(300,200)

        vbox.add(btn1)
        vbox.add(btn2)
        self.window.add(vbox)

        self.window.show_all()

    def main(self):
        gtk.main()

if __name__ == "__main__":
    vbox = VBoxLC()
    vbox.main()
</code></pre>

<p>在分析代码之前我们先来看一下VBox类的概要：</p>

<pre><code>class gtk.VBox(gtk.Box):
    gtk.VBox(homogeneous=False, spacing=0)
</code></pre>

<p>VBox的继承关系</p>

<pre><code>-- gobject.GObject
   -- gtk.Object
     -- gtk.Widget
       -- gtk.Container
         -- gtk.Box
           -- gtk.VBox
</code></pre>

<p>构造函数：</p>

<pre><code>gtk.VBox(homogeneous=False, spacing=0)
</code></pre>

<p><strong><code>homogeneous</code></strong> :</p>

<p>如果为 True 所有的子部件都会被分配均等的空间</p>

<p><strong><code>spacing</code></strong> :</p>

<p>垂直空间子部件之间的像素大小。</p>

<p><em>Returns</em> :</p>

<p>一个新的 gtk.VBox</p>

<p>如上面的例子来说，我们建立了一个 window ，然后建立了一个子部件空间分配不均等、子部件间隔5像素的VBox，然后建立两个Button，并且添加到VBox中，最后在把VBox添加到window中。最后就完成了一个简单的垂直排列的布局了。</p>

<h2>3.HBox</h2>

<p>接下来同样介绍一下HBox，它和VBox十分相似，不过它用来管理水平排列的布局，来看一个相同的示例，先上图：</p>

<p>[![][3]][3]</p>

<p>如上图，我们对比一下之前的图就很容易看出，HBox管理部件的水平排列布局，在很多应用程序的布局都是应用VBox和HBox配合使用来构建出丰富的UI来的。下面我们看一下完整代码，其实你很容易看出不同：</p>

<pre><code>#!/usr/bin/env python

# HBox layout container
# PyGtk Stady Notes By DawnDIY
# http://www.dawndiy.com

import pygtk
pygtk.require('2.0')
import gtk

class HBoxLC:
    def __init__(self):
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_title("HBox Layout Container")
        self.window.set_size_request(300,250)
        self.window.set_position(gtk.WIN_POS_CENTER)

        self.window.connect("destroy", gtk.main_quit)

        hbox = gtk.HBox(False, 5)
        btn1 = gtk.Button("small")
        btn2 = gtk.Button("Big")
        btn2.set_size_request(200,150)

        hbox.add(btn1)
        hbox.add(btn2)
        self.window.add(hbox)

        self.window.show_all()

    def main(self):
        gtk.main()

if __name__ == "__main__":
    hbox = HBoxLC()
    hbox.main()
</code></pre>

<p>下面同样是HBox类的概要和继承关系：</p>

<pre><code>class gtk.HBox(gtk.Box):
    gtk.HBox(homogeneous=False, spacing=0)

-- gobject.GObject
   -- gtk.Object
     -- gtk.Widget
       -- gtk.Container
         -- gtk.Box
           -- gtk.HBox
</code></pre>

<h2> 4.总结</h2>

<p>学习了一下VBox和HBox，非茶有用的两个布局管理部件，而且配合使用可以构建出非常复杂的UI，其实DawnDIY觉得VBox和HBox很容易让人想到HTML中的和标签，它们可以自由的相互嵌套来构建UI。所以你有好的设计，可以尝试一下用VBox和HBox把它设计出来吧。</p>

<p>今天学到这里，待续。。。</p>

<p> </p>

		
		
	</div>

<div class="meta">
	
		<span class="comments"><a href="/archives/107/blog/page/2/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/archives/97">
		
			PyGtk学习笔记(2)–布局管理(Fixed)</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: 








  


<time datetime="2012-07-07T00:00:00+08:00" pubdate data-updated="true">Jul 7<span>th</span>, 2012</time></div>
      <div class="tags">Tags: 


	<a class='category' href='/blog/categories/pygtk/'>PyGtk</a>, <a class='category' href='/blog/categories/python/'>Python</a>


</div>
    </div>
		<h1></h1>

<p>前面介绍了一下PyGtk，使用它可以做Python的GUI程序。在前面的例子中我们只实现了一个简单的窗口，那么要在窗口里面加内容怎么办？一个add就行了，但是如果想要做出包含丰富的元素，那么就要使用布局管理了。写过GUI的人都知道布局管理是多么重要的事情。虽然现在有很好的Glade工具来实现直接拖拽的方式来进行UI设计，但是毕竟学习的过程还是要从最基本的学起，所以和我一起来学习PyGtk的布局管理吧。</p>

<p>为了组织我们的部件,我们使用专门的不可见部件,其被称为布局容器 (layout containers)。PyGtk常用的有Alignment,Fixed,VBox和Table这四种布局容器(layout containers)。</p>

<p>这里先学习一下简单的Fixed布局，Fixed容器将放置位置固定和尺寸固定的子部件。这个容器不进行自动的布局管理。在大多数的程序中,我们不用这种容器。但是在一些专门的领域,我们会用它。例如游戏,一些工作在图表中的专门程序,那些能被移动可变化尺寸的组件(就想在电子表格程序中的一个chart表一样),小型的学习示例等。</p>

<p>A picture is worth a thousand words:</p>

<p>[![][2]][2]</p>

<p>如上图，我用了Fixed的布局方式，顺带展示一下Button的几种显示，完整代码如下：</p>

<pre><code>#!/usr/bin/env python

# Fixed layout container
# PyGtk Study Notes By DawnDIY
# http://dawndiy.com

import pygtk
pygtk.require('2.0')
import gtk

class FixedLC:
    def __init__(self):
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_title("Fixed Layout Container")
        self.window.set_size_request(300,250)
        self.window.set_position(gtk.WIN_POS_CENTER)

        btn1 = gtk.Button("Button1")
        btn2 = gtk.Button("Button2")
        btn3 = gtk.Button("Button3")
        btn4 = gtk.Button(stock = gtk.STOCK_CLOSE)

        btn2.set_sensitive(False)
        btn3.set_size_request(80,40)

        fixed = gtk.Fixed()

        fixed.put(btn1, 30, 30)
        fixed.put(btn2, 150, 30)
        fixed.put(btn3, 30, 130)
        fixed.put(btn4, 150, 130)

        btn4.connect("clicked", gtk.main_quit)
        self.window.connect("destroy", gtk.main_quit)

        self.window.add(fixed)
        self.window.show_all()

    def main(self):
        gtk.main()

if __name__ == "__main__":
    fixedLC = FixedLC()
    fixedLC.main()
</code></pre>

<p>分析上面的程序，我们设置了4个Button：btn1是一个普通的Button，btn2是一个不敏感的Button，btn3是一个自定义大小的Button，而btn4是根据GTK中的ITEM选择的一些常用Button。在窗口上，用Fixed容器来布局，调用put方法来向其添加部件，然后记得带上坐标就OK了，所以这种方法很简单，但是这中方法不通用，只能用在一些特殊界面中。</p>

<p>下面详细说一下Fixed：</p>

<p>Fixed的继承关系：</p>

<pre><code>-- gobject.GObject
   -- gtk.Object
     -- gtk.Widget
       -- gtk.Container
         -- gtk.Fixed
</code></pre>

<p>Fixed的概要：</p>

<pre><code>class gtk.Fixed(gtk.Container):
    gtk.Fixed()

    def put(widget, x, y)

    def move(widget, x, y)

    def set_has_window(has_window)

    def get_has_window()
</code></pre>

<p>这里列出的Fixed的函数。</p>

<pre><code>def put(widget, x, y)
</code></pre>

<p>添加一个widget，x、y分别是该widget在fixed中的横、纵坐标。（只要是x、y都是指widget的左上角）</p>

<pre><code>def move(widget, x, y)
</code></pre>

<p>移动一个widget，值得注意的是这里的widget一定要是已经添加的fixed中的widget，如果不是已经添加的，这个函数将不起任何作用。x、y分别是这个子widget需要移动到的坐标</p>

<pre><code>def set_has_window(has_window)
</code></pre>

<p><code>set_has_window</code>()方法指定根据has_window的值来决定是否创建一个单独的window。如果has_window的值为Ture，则fixed会创建它自己的单独的window。在默认情况下，has_window的值是False并且fixed会被建立在一个没有独立的window中。这个方法必须使用在fixed还没有实现的时候，例如，在window创建后立即使用。</p>

<pre><code>def get_has_window()
</code></pre>

<p>如果fixed拥有自己独立的window则返回True，否则返回False。</p>

<p> </p>

<p>这就是Fixed布局容器，只用坐标定位的简单布局，虽然不常用，但也是一个简单的布局，适用于一些小型示例中。这次就先学这么多，和大家分享这写。</p>

<p>待续布局容器。。。</p>

<p> </p>

		
		
	</div>

<div class="meta">
	
		<span class="comments"><a href="/archives/97/blog/page/2/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/archives/72">
		
			PyGtk学习笔记(1)&#8211;初窥PyGtk</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: 








  


<time datetime="2012-07-07T00:00:00+08:00" pubdate data-updated="true">Jul 7<span>th</span>, 2012</time></div>
      <div class="tags">Tags: 


	<a class='category' href='/blog/categories/pygtk/'>PyGtk</a>, <a class='category' href='/blog/categories/python/'>Python</a>


</div>
    </div>
		<h1></h1>

<p>之前一直在学习Python，Python确实是一门非常简练的编程语言。然而学习了一段时间后，用Python怎么做GUI程序呢，那这里有一个很好的GUI库可以使用，就是PyGtk。PyGtk是Gtk 的Python绑定版本，使用这个GUI可以方便的设计GUI程序。而且对比我之前用过的Java-Gnome，这个方便多了。所以要做GUI程序，值得学习一下PyGtk的使用，在此记录下自己的学习笔记分享给大家。</p>

<h2>1.PyGtk简介</h2>

<p><a href="http://zh.wikipedia.org/wiki/PyGTK" title="PyGtk Wiki">PyGtk</a>是一套用<a href="http://zh.wikipedia.org/wiki/Python" title="Python Wiki">Python</a>封装的GTK 的图形库，通过Python编程语言使用PyGtk图形库可以轻松的写出GUI程序。它是GNOME项目的一部分。PyGTK是基于LGPL许可之下的免费软件。其原始作者是James Henstridge。PyGTK非常容易使用,对于速成原型法,它是相当理想的。普遍地认为,PyGTK是最流行的GTK 库封装中的一种。</p>

<p>其中PyGtk包含几个模块：GObject、ATK、GTK、Pango、Cairo、Clade<br/>
GObject是基类,它为PyGTK所以类提供通用的属性和函数。</p>

<ul>
<li>ATK 是一个提供辅助功能的工具包。该工具包提供了帮助残障人士使用计算机的各种工具。</li>
<li>GTK 是用户界面模块。</li>
<li>Pango是一个用于处理文本和国际化的库。</li>
<li>Cairo是一个用于创建2D矢量模型的库。</li>
<li>Glade是用来从XML描述中构建GUI界面。</li>
</ul>


<p>如果你是Linux用户的话，不必担心安装配置问题，目前大部分Linux发行版中都包含了Python、PyGtk，所以直接用就行了。</p>

<h2>2.从一个简单示例开始</h2>

<p>先上图，接下来的程序效果如下图：</p>

<p>[![][4]][4]</p>

<p>很简单的一个窗口，下面是实现它的完整代码：</p>

<pre><code>#!/usr/bin/python
#-*- encoding:utf-8 -*-
#建立一个窗口

import gtk
class PyApp(gtk.Window):
    def __init__(self):
        super(PyApp, self).__init__()
        self.set_title("PyGtk")
        self.set_size_request(250, 150)
        self.set_position(gtk.WIN_POS_CENTER)

        self.connect("destroy", gtk.main_quit)

        self.show()

    def main(self):
        gtk.main()

print __name__
if __name__ == "__main__":
    pyapp = PyApp()
    pyapp.main()
</code></pre>

<p>使用PyGtk当然要有一定的Python基础，把上述代码保存为pygtkwin.py，在控制台执行如下命令就能看到一个窗口了。</p>

<pre><code>python pygtkwin.py
</code></pre>

<p>简单分析一下代码：</p>

<pre><code>import gtk
</code></pre>

<p>这里是导入PyGtk的gtk模块。</p>

<pre><code>self.set_title("PyGtk")
self.set_size_request(250, 150)
self.set_position(gtk.WIN_POS_CENTER)
</code></pre>

<p>这里的PyApp继承至GTK的窗口类，即gtk.Window。上面的set分别是设置窗口标题、窗口尺寸、窗口位置。</p>

<pre><code>self.connect("destroy", gtk.main_quit)
</code></pre>

<p>这里的connect是把该类的destroy事件绑定到gtk.main_quit方法上。效果就是点击窗口的关闭按钮，就会销毁整个装口。</p>

<pre><code>self.show()
</code></pre>

<p>用来现实这个窗口。</p>

<pre><code>gtk.main()
</code></pre>

<p>使用于启动GTK的循环，来保持窗口的运行。</p>

<p>到此，你就算初识PyGtk了。我也是在学习的过程，记录下自己的学习笔记和大家一起分享学习。待续…</p>

<p>一些有用的网站：<br/>
Python官网：<br/>
PyGtk官网：</p>

<p><strong>以后 PyGtk/PyGObject 学习笔记的代码全部在 github 上管理，地址：</strong></p>

<p> </p>

		
		
	</div>

<div class="meta">
	
		<span class="comments"><a href="/archives/72/blog/page/2/index.html#disqus_thread">Comments</a></span>
	
</div>
</article>

<nav id="pagenavi">
    
        <a href="/" class="prev">Prev</a>
    
    
        <a href="/blog/page/3/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>

    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2013

    DawnDIY
. Powered by <a href="http://octopress.org">Octopress</a> | 
    Theme <a href="http://github.com/panks/fabric">fabric</a> by <a href="http://panks.me">Pankaj Kumar</a>
</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'DawnDIY';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
</body>
</html>
